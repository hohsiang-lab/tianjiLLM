// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: model_pricing.sql

package db

import (
	"context"
)

const deleteAllModelPricing = `-- name: DeleteAllModelPricing :exec
DELETE FROM "ModelPricing"
`

func (q *Queries) DeleteAllModelPricing(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteAllModelPricing)
	return err
}

const listModelPricing = `-- name: ListModelPricing :many
SELECT model_name, input_cost_per_token, output_cost_per_token, max_input_tokens, max_output_tokens, max_tokens, mode, provider, source_url, cache_read_input_token_cost, cache_creation_input_token_cost, cache_read_input_token_cost_above_200k, cache_creation_input_token_cost_above_200k, synced_at, created_at, updated_at FROM "ModelPricing"
ORDER BY model_name
`

func (q *Queries) ListModelPricing(ctx context.Context) ([]ModelPricing, error) {
	rows, err := q.db.Query(ctx, listModelPricing)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ModelPricing
	for rows.Next() {
		var i ModelPricing
		if err := rows.Scan(
			&i.ModelName,
			&i.InputCostPerToken,
			&i.OutputCostPerToken,
			&i.MaxInputTokens,
			&i.MaxOutputTokens,
			&i.MaxTokens,
			&i.Mode,
			&i.Provider,
			&i.SourceUrl,
			&i.CacheReadInputTokenCost,
			&i.CacheCreationInputTokenCost,
			&i.CacheReadInputTokenCostAbove200k,
			&i.CacheCreationInputTokenCostAbove200k,
			&i.SyncedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertModelPricing = `-- name: UpsertModelPricing :exec
INSERT INTO "ModelPricing" (
    model_name, input_cost_per_token, output_cost_per_token,
    max_input_tokens, max_output_tokens, max_tokens,
    mode, provider, source_url,
    cache_read_input_token_cost, cache_creation_input_token_cost,
    cache_read_input_token_cost_above_200k, cache_creation_input_token_cost_above_200k,
    synced_at
) VALUES (
    $1, $2, $3,
    $4, $5, $6,
    $7, $8, $9,
    $10, $11,
    $12, $13,
    NOW()
)
ON CONFLICT (model_name) DO UPDATE SET
    input_cost_per_token  = EXCLUDED.input_cost_per_token,
    output_cost_per_token = EXCLUDED.output_cost_per_token,
    max_input_tokens      = EXCLUDED.max_input_tokens,
    max_output_tokens     = EXCLUDED.max_output_tokens,
    max_tokens            = EXCLUDED.max_tokens,
    mode                  = EXCLUDED.mode,
    provider              = EXCLUDED.provider,
    source_url            = EXCLUDED.source_url,
    cache_read_input_token_cost             = EXCLUDED.cache_read_input_token_cost,
    cache_creation_input_token_cost         = EXCLUDED.cache_creation_input_token_cost,
    cache_read_input_token_cost_above_200k  = EXCLUDED.cache_read_input_token_cost_above_200k,
    cache_creation_input_token_cost_above_200k = EXCLUDED.cache_creation_input_token_cost_above_200k,
    synced_at             = NOW(),
    updated_at            = NOW()
`

type UpsertModelPricingParams struct {
	ModelName                            string  `json:"model_name"`
	InputCostPerToken                    float64 `json:"input_cost_per_token"`
	OutputCostPerToken                   float64 `json:"output_cost_per_token"`
	MaxInputTokens                       int32   `json:"max_input_tokens"`
	MaxOutputTokens                      int32   `json:"max_output_tokens"`
	MaxTokens                            int32   `json:"max_tokens"`
	Mode                                 string  `json:"mode"`
	Provider                             string  `json:"provider"`
	SourceUrl                            string  `json:"source_url"`
	CacheReadInputTokenCost              float64 `json:"cache_read_input_token_cost"`
	CacheCreationInputTokenCost          float64 `json:"cache_creation_input_token_cost"`
	CacheReadInputTokenCostAbove200k     float64 `json:"cache_read_input_token_cost_above_200k"`
	CacheCreationInputTokenCostAbove200k float64 `json:"cache_creation_input_token_cost_above_200k"`
}

func (q *Queries) UpsertModelPricing(ctx context.Context, arg UpsertModelPricingParams) error {
	_, err := q.db.Exec(ctx, upsertModelPricing,
		arg.ModelName,
		arg.InputCostPerToken,
		arg.OutputCostPerToken,
		arg.MaxInputTokens,
		arg.MaxOutputTokens,
		arg.MaxTokens,
		arg.Mode,
		arg.Provider,
		arg.SourceUrl,
		arg.CacheReadInputTokenCost,
		arg.CacheCreationInputTokenCost,
		arg.CacheReadInputTokenCostAbove200k,
		arg.CacheCreationInputTokenCostAbove200k,
	)
	return err
}
