// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: model_pricing.sql

package db

import (
	"context"
)

const deleteAllModelPricing = `-- name: DeleteAllModelPricing :exec
DELETE FROM "ModelPricing"
`

func (q *Queries) DeleteAllModelPricing(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteAllModelPricing)
	return err
}

const listModelPricing = `-- name: ListModelPricing :many
SELECT model_name, input_cost_per_token, output_cost_per_token, max_input_tokens, max_output_tokens, max_tokens, mode, provider, source_url, synced_at, created_at, updated_at FROM "ModelPricing"
ORDER BY model_name
`

func (q *Queries) ListModelPricing(ctx context.Context) ([]ModelPricing, error) {
	rows, err := q.db.Query(ctx, listModelPricing)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ModelPricing
	for rows.Next() {
		var i ModelPricing
		if err := rows.Scan(
			&i.ModelName,
			&i.InputCostPerToken,
			&i.OutputCostPerToken,
			&i.MaxInputTokens,
			&i.MaxOutputTokens,
			&i.MaxTokens,
			&i.Mode,
			&i.Provider,
			&i.SourceUrl,
			&i.SyncedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertModelPricing = `-- name: UpsertModelPricing :exec
INSERT INTO "ModelPricing" (
    model_name, input_cost_per_token, output_cost_per_token,
    max_input_tokens, max_output_tokens, max_tokens,
    mode, provider, source_url, synced_at
) VALUES (
    $1, $2, $3,
    $4, $5, $6,
    $7, $8, $9, NOW()
)
ON CONFLICT (model_name) DO UPDATE SET
    input_cost_per_token  = EXCLUDED.input_cost_per_token,
    output_cost_per_token = EXCLUDED.output_cost_per_token,
    max_input_tokens      = EXCLUDED.max_input_tokens,
    max_output_tokens     = EXCLUDED.max_output_tokens,
    max_tokens            = EXCLUDED.max_tokens,
    mode                  = EXCLUDED.mode,
    provider              = EXCLUDED.provider,
    source_url            = EXCLUDED.source_url,
    synced_at             = NOW(),
    updated_at            = NOW()
`

type UpsertModelPricingParams struct {
	ModelName          string  `json:"model_name"`
	InputCostPerToken  float64 `json:"input_cost_per_token"`
	OutputCostPerToken float64 `json:"output_cost_per_token"`
	MaxInputTokens     int32   `json:"max_input_tokens"`
	MaxOutputTokens    int32   `json:"max_output_tokens"`
	MaxTokens          int32   `json:"max_tokens"`
	Mode               string  `json:"mode"`
	Provider           string  `json:"provider"`
	SourceUrl          string  `json:"source_url"`
}

func (q *Queries) UpsertModelPricing(ctx context.Context, arg UpsertModelPricingParams) error {
	_, err := q.db.Exec(ctx, upsertModelPricing,
		arg.ModelName,
		arg.InputCostPerToken,
		arg.OutputCostPerToken,
		arg.MaxInputTokens,
		arg.MaxOutputTokens,
		arg.MaxTokens,
		arg.Mode,
		arg.Provider,
		arg.SourceUrl,
	)
	return err
}
