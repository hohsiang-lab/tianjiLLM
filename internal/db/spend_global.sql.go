// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: spend_global.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getCacheHitStats = `-- name: GetCacheHitStats :many
SELECT
    DATE(starttime) as date,
    COUNT(CASE WHEN cache_hit = 'True' THEN 1 END) as cache_hits,
    COUNT(CASE WHEN cache_hit != 'True' OR cache_hit = '' THEN 1 END) as cache_misses,
    COUNT(*) as total_requests
FROM "SpendLogs"
WHERE starttime >= $1 AND starttime <= $2
GROUP BY DATE(starttime)
ORDER BY date DESC
`

type GetCacheHitStatsParams struct {
	Starttime   pgtype.Timestamptz `json:"starttime"`
	Starttime_2 pgtype.Timestamptz `json:"starttime_2"`
}

type GetCacheHitStatsRow struct {
	Date          pgtype.Date `json:"date"`
	CacheHits     int64       `json:"cache_hits"`
	CacheMisses   int64       `json:"cache_misses"`
	TotalRequests int64       `json:"total_requests"`
}

func (q *Queries) GetCacheHitStats(ctx context.Context, arg GetCacheHitStatsParams) ([]GetCacheHitStatsRow, error) {
	rows, err := q.db.Query(ctx, getCacheHitStats, arg.Starttime, arg.Starttime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCacheHitStatsRow
	for rows.Next() {
		var i GetCacheHitStatsRow
		if err := rows.Scan(
			&i.Date,
			&i.CacheHits,
			&i.CacheMisses,
			&i.TotalRequests,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGlobalActivity = `-- name: GetGlobalActivity :many
SELECT
    DATE(starttime) as date,
    COUNT(*) as request_count,
    SUM(prompt_tokens) as total_prompt_tokens,
    SUM(completion_tokens) as total_completion_tokens,
    SUM(total_tokens) as total_tokens,
    SUM(spend) as total_spend
FROM "SpendLogs"
WHERE starttime >= $1 AND starttime <= $2
GROUP BY DATE(starttime)
ORDER BY date DESC
`

type GetGlobalActivityParams struct {
	Starttime   pgtype.Timestamptz `json:"starttime"`
	Starttime_2 pgtype.Timestamptz `json:"starttime_2"`
}

type GetGlobalActivityRow struct {
	Date                  pgtype.Date `json:"date"`
	RequestCount          int64       `json:"request_count"`
	TotalPromptTokens     int64       `json:"total_prompt_tokens"`
	TotalCompletionTokens int64       `json:"total_completion_tokens"`
	TotalTokens           int64       `json:"total_tokens"`
	TotalSpend            int64       `json:"total_spend"`
}

func (q *Queries) GetGlobalActivity(ctx context.Context, arg GetGlobalActivityParams) ([]GetGlobalActivityRow, error) {
	rows, err := q.db.Query(ctx, getGlobalActivity, arg.Starttime, arg.Starttime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGlobalActivityRow
	for rows.Next() {
		var i GetGlobalActivityRow
		if err := rows.Scan(
			&i.Date,
			&i.RequestCount,
			&i.TotalPromptTokens,
			&i.TotalCompletionTokens,
			&i.TotalTokens,
			&i.TotalSpend,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGlobalActivityByModel = `-- name: GetGlobalActivityByModel :many
SELECT
    model,
    DATE(starttime) as date,
    COUNT(*) as request_count,
    SUM(prompt_tokens) as total_prompt_tokens,
    SUM(completion_tokens) as total_completion_tokens,
    SUM(spend) as total_spend
FROM "SpendLogs"
WHERE starttime >= $1 AND starttime <= $2
GROUP BY model, DATE(starttime)
ORDER BY date DESC, model
`

type GetGlobalActivityByModelParams struct {
	Starttime   pgtype.Timestamptz `json:"starttime"`
	Starttime_2 pgtype.Timestamptz `json:"starttime_2"`
}

type GetGlobalActivityByModelRow struct {
	Model                 string      `json:"model"`
	Date                  pgtype.Date `json:"date"`
	RequestCount          int64       `json:"request_count"`
	TotalPromptTokens     int64       `json:"total_prompt_tokens"`
	TotalCompletionTokens int64       `json:"total_completion_tokens"`
	TotalSpend            int64       `json:"total_spend"`
}

func (q *Queries) GetGlobalActivityByModel(ctx context.Context, arg GetGlobalActivityByModelParams) ([]GetGlobalActivityByModelRow, error) {
	rows, err := q.db.Query(ctx, getGlobalActivityByModel, arg.Starttime, arg.Starttime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGlobalActivityByModelRow
	for rows.Next() {
		var i GetGlobalActivityByModelRow
		if err := rows.Scan(
			&i.Model,
			&i.Date,
			&i.RequestCount,
			&i.TotalPromptTokens,
			&i.TotalCompletionTokens,
			&i.TotalSpend,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGlobalSpendReport = `-- name: GetGlobalSpendReport :many
SELECT
    COALESCE(team_id, '') as group_key,
    DATE(starttime) as date,
    SUM(spend) as total_spend,
    COUNT(*) as request_count
FROM "SpendLogs"
WHERE starttime >= $1 AND starttime <= $2
GROUP BY group_key, DATE(starttime)
ORDER BY date DESC
`

type GetGlobalSpendReportParams struct {
	Starttime   pgtype.Timestamptz `json:"starttime"`
	Starttime_2 pgtype.Timestamptz `json:"starttime_2"`
}

type GetGlobalSpendReportRow struct {
	GroupKey     string      `json:"group_key"`
	Date         pgtype.Date `json:"date"`
	TotalSpend   int64       `json:"total_spend"`
	RequestCount int64       `json:"request_count"`
}

func (q *Queries) GetGlobalSpendReport(ctx context.Context, arg GetGlobalSpendReportParams) ([]GetGlobalSpendReportRow, error) {
	rows, err := q.db.Query(ctx, getGlobalSpendReport, arg.Starttime, arg.Starttime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGlobalSpendReportRow
	for rows.Next() {
		var i GetGlobalSpendReportRow
		if err := rows.Scan(
			&i.GroupKey,
			&i.Date,
			&i.TotalSpend,
			&i.RequestCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGlobalSpendReportByCustomer = `-- name: GetGlobalSpendReportByCustomer :many
SELECT
    COALESCE(end_user, '') as group_key,
    DATE(starttime) as date,
    SUM(spend) as total_spend,
    COUNT(*) as request_count
FROM "SpendLogs"
WHERE starttime >= $1 AND starttime <= $2
GROUP BY group_key, DATE(starttime)
ORDER BY date DESC
`

type GetGlobalSpendReportByCustomerParams struct {
	Starttime   pgtype.Timestamptz `json:"starttime"`
	Starttime_2 pgtype.Timestamptz `json:"starttime_2"`
}

type GetGlobalSpendReportByCustomerRow struct {
	GroupKey     string      `json:"group_key"`
	Date         pgtype.Date `json:"date"`
	TotalSpend   int64       `json:"total_spend"`
	RequestCount int64       `json:"request_count"`
}

func (q *Queries) GetGlobalSpendReportByCustomer(ctx context.Context, arg GetGlobalSpendReportByCustomerParams) ([]GetGlobalSpendReportByCustomerRow, error) {
	rows, err := q.db.Query(ctx, getGlobalSpendReportByCustomer, arg.Starttime, arg.Starttime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGlobalSpendReportByCustomerRow
	for rows.Next() {
		var i GetGlobalSpendReportByCustomerRow
		if err := rows.Scan(
			&i.GroupKey,
			&i.Date,
			&i.TotalSpend,
			&i.RequestCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGlobalSpendReportByKey = `-- name: GetGlobalSpendReportByKey :many
SELECT
    api_key as group_key,
    DATE(starttime) as date,
    SUM(spend) as total_spend,
    COUNT(*) as request_count
FROM "SpendLogs"
WHERE starttime >= $1 AND starttime <= $2
GROUP BY group_key, DATE(starttime)
ORDER BY date DESC
`

type GetGlobalSpendReportByKeyParams struct {
	Starttime   pgtype.Timestamptz `json:"starttime"`
	Starttime_2 pgtype.Timestamptz `json:"starttime_2"`
}

type GetGlobalSpendReportByKeyRow struct {
	GroupKey     string      `json:"group_key"`
	Date         pgtype.Date `json:"date"`
	TotalSpend   int64       `json:"total_spend"`
	RequestCount int64       `json:"request_count"`
}

func (q *Queries) GetGlobalSpendReportByKey(ctx context.Context, arg GetGlobalSpendReportByKeyParams) ([]GetGlobalSpendReportByKeyRow, error) {
	rows, err := q.db.Query(ctx, getGlobalSpendReportByKey, arg.Starttime, arg.Starttime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGlobalSpendReportByKeyRow
	for rows.Next() {
		var i GetGlobalSpendReportByKeyRow
		if err := rows.Scan(
			&i.GroupKey,
			&i.Date,
			&i.TotalSpend,
			&i.RequestCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVerificationTokenBatch = `-- name: GetVerificationTokenBatch :many
SELECT token, key_name, key_alias, spend, max_budget, expires, models, aliases, config, user_id, team_id, organization_id, permissions, metadata, blocked, tpm_limit, rpm_limit, budget_duration, budget_reset_at, allowed_cache_controls, allowed_routes, policies, access_group_ids, model_spend, model_max_budget, soft_budget_cooldown, budget_id, object_permission_id, created_at, created_by, updated_at, updated_by FROM "VerificationToken"
WHERE token = ANY($1::text[])
`

func (q *Queries) GetVerificationTokenBatch(ctx context.Context, dollar_1 []string) ([]VerificationToken, error) {
	rows, err := q.db.Query(ctx, getVerificationTokenBatch, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VerificationToken
	for rows.Next() {
		var i VerificationToken
		if err := rows.Scan(
			&i.Token,
			&i.KeyName,
			&i.KeyAlias,
			&i.Spend,
			&i.MaxBudget,
			&i.Expires,
			&i.Models,
			&i.Aliases,
			&i.Config,
			&i.UserID,
			&i.TeamID,
			&i.OrganizationID,
			&i.Permissions,
			&i.Metadata,
			&i.Blocked,
			&i.TpmLimit,
			&i.RpmLimit,
			&i.BudgetDuration,
			&i.BudgetResetAt,
			&i.AllowedCacheControls,
			&i.AllowedRoutes,
			&i.Policies,
			&i.AccessGroupIds,
			&i.ModelSpend,
			&i.ModelMaxBudget,
			&i.SoftBudgetCooldown,
			&i.BudgetID,
			&i.ObjectPermissionID,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDistinctKeyAliases = `-- name: ListDistinctKeyAliases :many
SELECT DISTINCT key_alias
FROM "VerificationToken"
WHERE key_alias IS NOT NULL AND key_alias != ''
ORDER BY key_alias
`

func (q *Queries) ListDistinctKeyAliases(ctx context.Context) ([]*string, error) {
	rows, err := q.db.Query(ctx, listDistinctKeyAliases)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*string
	for rows.Next() {
		var key_alias *string
		if err := rows.Scan(&key_alias); err != nil {
			return nil, err
		}
		items = append(items, key_alias)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetAllKeySpend = `-- name: ResetAllKeySpend :exec
UPDATE "VerificationToken"
SET spend = 0, updated_at = NOW()
`

func (q *Queries) ResetAllKeySpend(ctx context.Context) error {
	_, err := q.db.Exec(ctx, resetAllKeySpend)
	return err
}

const resetAllTeamSpend = `-- name: ResetAllTeamSpend :exec
UPDATE "TeamTable"
SET spend = 0, updated_at = NOW()
`

func (q *Queries) ResetAllTeamSpend(ctx context.Context) error {
	_, err := q.db.Exec(ctx, resetAllTeamSpend)
	return err
}

const resetKeySpendByToken = `-- name: ResetKeySpendByToken :exec
UPDATE "VerificationToken"
SET spend = $2, updated_at = NOW()
WHERE token = $1
`

type ResetKeySpendByTokenParams struct {
	Token string  `json:"token"`
	Spend float64 `json:"spend"`
}

func (q *Queries) ResetKeySpendByToken(ctx context.Context, arg ResetKeySpendByTokenParams) error {
	_, err := q.db.Exec(ctx, resetKeySpendByToken, arg.Token, arg.Spend)
	return err
}
