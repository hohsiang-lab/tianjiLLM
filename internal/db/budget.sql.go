// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: budget.sql

package db

import (
	"context"
)

const createBudget = `-- name: CreateBudget :one
INSERT INTO "BudgetTable" (budget_id, max_budget, soft_budget, max_parallel_requests, tpm_limit, rpm_limit, budget_duration, created_by)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING budget_id, max_budget, soft_budget, max_parallel_requests, tpm_limit, rpm_limit, model_max_budget, budget_duration, budget_reset_at, created_at, created_by, updated_at, updated_by
`

type CreateBudgetParams struct {
	BudgetID            string   `json:"budget_id"`
	MaxBudget           *float64 `json:"max_budget"`
	SoftBudget          *float64 `json:"soft_budget"`
	MaxParallelRequests *int32   `json:"max_parallel_requests"`
	TpmLimit            *int64   `json:"tpm_limit"`
	RpmLimit            *int64   `json:"rpm_limit"`
	BudgetDuration      *string  `json:"budget_duration"`
	CreatedBy           string   `json:"created_by"`
}

func (q *Queries) CreateBudget(ctx context.Context, arg CreateBudgetParams) (BudgetTable, error) {
	row := q.db.QueryRow(ctx, createBudget,
		arg.BudgetID,
		arg.MaxBudget,
		arg.SoftBudget,
		arg.MaxParallelRequests,
		arg.TpmLimit,
		arg.RpmLimit,
		arg.BudgetDuration,
		arg.CreatedBy,
	)
	var i BudgetTable
	err := row.Scan(
		&i.BudgetID,
		&i.MaxBudget,
		&i.SoftBudget,
		&i.MaxParallelRequests,
		&i.TpmLimit,
		&i.RpmLimit,
		&i.ModelMaxBudget,
		&i.BudgetDuration,
		&i.BudgetResetAt,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const deleteBudget = `-- name: DeleteBudget :exec
DELETE FROM "BudgetTable" WHERE budget_id = $1
`

func (q *Queries) DeleteBudget(ctx context.Context, budgetID string) error {
	_, err := q.db.Exec(ctx, deleteBudget, budgetID)
	return err
}

const getBudget = `-- name: GetBudget :one
SELECT budget_id, max_budget, soft_budget, max_parallel_requests, tpm_limit, rpm_limit, model_max_budget, budget_duration, budget_reset_at, created_at, created_by, updated_at, updated_by FROM "BudgetTable" WHERE budget_id = $1
`

func (q *Queries) GetBudget(ctx context.Context, budgetID string) (BudgetTable, error) {
	row := q.db.QueryRow(ctx, getBudget, budgetID)
	var i BudgetTable
	err := row.Scan(
		&i.BudgetID,
		&i.MaxBudget,
		&i.SoftBudget,
		&i.MaxParallelRequests,
		&i.TpmLimit,
		&i.RpmLimit,
		&i.ModelMaxBudget,
		&i.BudgetDuration,
		&i.BudgetResetAt,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const listBudgets = `-- name: ListBudgets :many
SELECT budget_id, max_budget, soft_budget, max_parallel_requests, tpm_limit, rpm_limit, model_max_budget, budget_duration, budget_reset_at, created_at, created_by, updated_at, updated_by FROM "BudgetTable" ORDER BY created_at DESC
`

func (q *Queries) ListBudgets(ctx context.Context) ([]BudgetTable, error) {
	rows, err := q.db.Query(ctx, listBudgets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BudgetTable
	for rows.Next() {
		var i BudgetTable
		if err := rows.Scan(
			&i.BudgetID,
			&i.MaxBudget,
			&i.SoftBudget,
			&i.MaxParallelRequests,
			&i.TpmLimit,
			&i.RpmLimit,
			&i.ModelMaxBudget,
			&i.BudgetDuration,
			&i.BudgetResetAt,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBudget = `-- name: UpdateBudget :one
UPDATE "BudgetTable"
SET max_budget = COALESCE($2, max_budget),
    soft_budget = COALESCE($3, soft_budget),
    tpm_limit = COALESCE($4, tpm_limit),
    rpm_limit = COALESCE($5, rpm_limit),
    updated_at = NOW(),
    updated_by = $6
WHERE budget_id = $1
RETURNING budget_id, max_budget, soft_budget, max_parallel_requests, tpm_limit, rpm_limit, model_max_budget, budget_duration, budget_reset_at, created_at, created_by, updated_at, updated_by
`

type UpdateBudgetParams struct {
	BudgetID   string   `json:"budget_id"`
	MaxBudget  *float64 `json:"max_budget"`
	SoftBudget *float64 `json:"soft_budget"`
	TpmLimit   *int64   `json:"tpm_limit"`
	RpmLimit   *int64   `json:"rpm_limit"`
	UpdatedBy  string   `json:"updated_by"`
}

func (q *Queries) UpdateBudget(ctx context.Context, arg UpdateBudgetParams) (BudgetTable, error) {
	row := q.db.QueryRow(ctx, updateBudget,
		arg.BudgetID,
		arg.MaxBudget,
		arg.SoftBudget,
		arg.TpmLimit,
		arg.RpmLimit,
		arg.UpdatedBy,
	)
	var i BudgetTable
	err := row.Scan(
		&i.BudgetID,
		&i.MaxBudget,
		&i.SoftBudget,
		&i.MaxParallelRequests,
		&i.TpmLimit,
		&i.RpmLimit,
		&i.ModelMaxBudget,
		&i.BudgetDuration,
		&i.BudgetResetAt,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}
