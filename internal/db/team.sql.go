// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: team.sql

package db

import (
	"context"
)

const addTeamMember = `-- name: AddTeamMember :exec
UPDATE "TeamTable"
SET members = array_append(members, $2), updated_at = NOW()
WHERE team_id = $1
`

type AddTeamMemberParams struct {
	TeamID      string      `json:"team_id"`
	ArrayAppend interface{} `json:"array_append"`
}

func (q *Queries) AddTeamMember(ctx context.Context, arg AddTeamMemberParams) error {
	_, err := q.db.Exec(ctx, addTeamMember, arg.TeamID, arg.ArrayAppend)
	return err
}

const addTeamModel = `-- name: AddTeamModel :exec
UPDATE "TeamTable"
SET models = array_append(models, $2), updated_at = NOW()
WHERE team_id = $1
`

type AddTeamModelParams struct {
	TeamID      string      `json:"team_id"`
	ArrayAppend interface{} `json:"array_append"`
}

func (q *Queries) AddTeamModel(ctx context.Context, arg AddTeamModelParams) error {
	_, err := q.db.Exec(ctx, addTeamModel, arg.TeamID, arg.ArrayAppend)
	return err
}

const blockTeam = `-- name: BlockTeam :exec
UPDATE "TeamTable"
SET blocked = TRUE, updated_at = NOW()
WHERE team_id = $1
`

func (q *Queries) BlockTeam(ctx context.Context, teamID string) error {
	_, err := q.db.Exec(ctx, blockTeam, teamID)
	return err
}

const createTeam = `-- name: CreateTeam :one
INSERT INTO "TeamTable" (team_id, team_alias, organization_id, admins, members, max_budget, models, tpm_limit, rpm_limit, budget_duration, created_by)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING team_id, team_alias, organization_id, admins, members, members_with_roles, metadata, max_budget, spend, models, blocked, tpm_limit, rpm_limit, budget_duration, budget_reset_at, budget_id, created_at, created_by, updated_at, updated_by
`

type CreateTeamParams struct {
	TeamID         string   `json:"team_id"`
	TeamAlias      *string  `json:"team_alias"`
	OrganizationID *string  `json:"organization_id"`
	Admins         []string `json:"admins"`
	Members        []string `json:"members"`
	MaxBudget      *float64 `json:"max_budget"`
	Models         []string `json:"models"`
	TpmLimit       *int64   `json:"tpm_limit"`
	RpmLimit       *int64   `json:"rpm_limit"`
	BudgetDuration *string  `json:"budget_duration"`
	CreatedBy      string   `json:"created_by"`
}

func (q *Queries) CreateTeam(ctx context.Context, arg CreateTeamParams) (TeamTable, error) {
	row := q.db.QueryRow(ctx, createTeam,
		arg.TeamID,
		arg.TeamAlias,
		arg.OrganizationID,
		arg.Admins,
		arg.Members,
		arg.MaxBudget,
		arg.Models,
		arg.TpmLimit,
		arg.RpmLimit,
		arg.BudgetDuration,
		arg.CreatedBy,
	)
	var i TeamTable
	err := row.Scan(
		&i.TeamID,
		&i.TeamAlias,
		&i.OrganizationID,
		&i.Admins,
		&i.Members,
		&i.MembersWithRoles,
		&i.Metadata,
		&i.MaxBudget,
		&i.Spend,
		&i.Models,
		&i.Blocked,
		&i.TpmLimit,
		&i.RpmLimit,
		&i.BudgetDuration,
		&i.BudgetResetAt,
		&i.BudgetID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const deleteTeam = `-- name: DeleteTeam :exec
DELETE FROM "TeamTable" WHERE team_id = $1
`

func (q *Queries) DeleteTeam(ctx context.Context, teamID string) error {
	_, err := q.db.Exec(ctx, deleteTeam, teamID)
	return err
}

const getTeam = `-- name: GetTeam :one
SELECT team_id, team_alias, organization_id, admins, members, members_with_roles, metadata, max_budget, spend, models, blocked, tpm_limit, rpm_limit, budget_duration, budget_reset_at, budget_id, created_at, created_by, updated_at, updated_by FROM "TeamTable" WHERE team_id = $1
`

func (q *Queries) GetTeam(ctx context.Context, teamID string) (TeamTable, error) {
	row := q.db.QueryRow(ctx, getTeam, teamID)
	var i TeamTable
	err := row.Scan(
		&i.TeamID,
		&i.TeamAlias,
		&i.OrganizationID,
		&i.Admins,
		&i.Members,
		&i.MembersWithRoles,
		&i.Metadata,
		&i.MaxBudget,
		&i.Spend,
		&i.Models,
		&i.Blocked,
		&i.TpmLimit,
		&i.RpmLimit,
		&i.BudgetDuration,
		&i.BudgetResetAt,
		&i.BudgetID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const getTeamByAlias = `-- name: GetTeamByAlias :one
SELECT team_id, team_alias, organization_id, admins, members, members_with_roles, metadata, max_budget, spend, models, blocked, tpm_limit, rpm_limit, budget_duration, budget_reset_at, budget_id, created_at, created_by, updated_at, updated_by FROM "TeamTable" WHERE team_alias = $1
`

func (q *Queries) GetTeamByAlias(ctx context.Context, teamAlias *string) (TeamTable, error) {
	row := q.db.QueryRow(ctx, getTeamByAlias, teamAlias)
	var i TeamTable
	err := row.Scan(
		&i.TeamID,
		&i.TeamAlias,
		&i.OrganizationID,
		&i.Admins,
		&i.Members,
		&i.MembersWithRoles,
		&i.Metadata,
		&i.MaxBudget,
		&i.Spend,
		&i.Models,
		&i.Blocked,
		&i.TpmLimit,
		&i.RpmLimit,
		&i.BudgetDuration,
		&i.BudgetResetAt,
		&i.BudgetID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const getTeamCallback = `-- name: GetTeamCallback :one
SELECT metadata->'callback_settings' as callback_settings FROM "TeamTable"
WHERE team_id = $1
`

func (q *Queries) GetTeamCallback(ctx context.Context, teamID string) (interface{}, error) {
	row := q.db.QueryRow(ctx, getTeamCallback, teamID)
	var callback_settings interface{}
	err := row.Scan(&callback_settings)
	return callback_settings, err
}

const getTeamPermissions = `-- name: GetTeamPermissions :one
SELECT metadata FROM "TeamTable"
WHERE team_id = $1
`

func (q *Queries) GetTeamPermissions(ctx context.Context, teamID string) ([]byte, error) {
	row := q.db.QueryRow(ctx, getTeamPermissions, teamID)
	var metadata []byte
	err := row.Scan(&metadata)
	return metadata, err
}

const listAvailableTeams = `-- name: ListAvailableTeams :many
SELECT team_id, team_alias, organization_id, admins, members, members_with_roles, metadata, max_budget, spend, models, blocked, tpm_limit, rpm_limit, budget_duration, budget_reset_at, budget_id, created_at, created_by, updated_at, updated_by FROM "TeamTable"
WHERE blocked = FALSE
ORDER BY created_at DESC
`

func (q *Queries) ListAvailableTeams(ctx context.Context) ([]TeamTable, error) {
	rows, err := q.db.Query(ctx, listAvailableTeams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TeamTable
	for rows.Next() {
		var i TeamTable
		if err := rows.Scan(
			&i.TeamID,
			&i.TeamAlias,
			&i.OrganizationID,
			&i.Admins,
			&i.Members,
			&i.MembersWithRoles,
			&i.Metadata,
			&i.MaxBudget,
			&i.Spend,
			&i.Models,
			&i.Blocked,
			&i.TpmLimit,
			&i.RpmLimit,
			&i.BudgetDuration,
			&i.BudgetResetAt,
			&i.BudgetID,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamAliases = `-- name: ListTeamAliases :many
SELECT team_id, team_alias FROM "TeamTable"
WHERE team_id = ANY($1::text[])
`

type ListTeamAliasesRow struct {
	TeamID    string  `json:"team_id"`
	TeamAlias *string `json:"team_alias"`
}

func (q *Queries) ListTeamAliases(ctx context.Context, teamIds []string) ([]ListTeamAliasesRow, error) {
	rows, err := q.db.Query(ctx, listTeamAliases, teamIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTeamAliasesRow
	for rows.Next() {
		var i ListTeamAliasesRow
		if err := rows.Scan(&i.TeamID, &i.TeamAlias); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeams = `-- name: ListTeams :many
SELECT team_id, team_alias, organization_id, admins, members, members_with_roles, metadata, max_budget, spend, models, blocked, tpm_limit, rpm_limit, budget_duration, budget_reset_at, budget_id, created_at, created_by, updated_at, updated_by FROM "TeamTable" ORDER BY created_at DESC
`

func (q *Queries) ListTeams(ctx context.Context) ([]TeamTable, error) {
	rows, err := q.db.Query(ctx, listTeams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TeamTable
	for rows.Next() {
		var i TeamTable
		if err := rows.Scan(
			&i.TeamID,
			&i.TeamAlias,
			&i.OrganizationID,
			&i.Admins,
			&i.Members,
			&i.MembersWithRoles,
			&i.Metadata,
			&i.MaxBudget,
			&i.Spend,
			&i.Models,
			&i.Blocked,
			&i.TpmLimit,
			&i.RpmLimit,
			&i.BudgetDuration,
			&i.BudgetResetAt,
			&i.BudgetID,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeTeamMember = `-- name: RemoveTeamMember :exec
UPDATE "TeamTable"
SET members = array_remove(members, $2), updated_at = NOW()
WHERE team_id = $1
`

type RemoveTeamMemberParams struct {
	TeamID      string      `json:"team_id"`
	ArrayRemove interface{} `json:"array_remove"`
}

func (q *Queries) RemoveTeamMember(ctx context.Context, arg RemoveTeamMemberParams) error {
	_, err := q.db.Exec(ctx, removeTeamMember, arg.TeamID, arg.ArrayRemove)
	return err
}

const removeTeamModel = `-- name: RemoveTeamModel :exec
UPDATE "TeamTable"
SET models = array_remove(models, $2), updated_at = NOW()
WHERE team_id = $1
`

type RemoveTeamModelParams struct {
	TeamID      string      `json:"team_id"`
	ArrayRemove interface{} `json:"array_remove"`
}

func (q *Queries) RemoveTeamModel(ctx context.Context, arg RemoveTeamModelParams) error {
	_, err := q.db.Exec(ctx, removeTeamModel, arg.TeamID, arg.ArrayRemove)
	return err
}

const resetTeamSpend = `-- name: ResetTeamSpend :exec
UPDATE "TeamTable"
SET spend = 0, updated_at = NOW()
WHERE team_id = $1
`

func (q *Queries) ResetTeamSpend(ctx context.Context, teamID string) error {
	_, err := q.db.Exec(ctx, resetTeamSpend, teamID)
	return err
}

const setTeamCallback = `-- name: SetTeamCallback :exec
UPDATE "TeamTable"
SET metadata = jsonb_set(COALESCE(metadata, '{}'), '{callback_settings}', $2::jsonb), updated_at = NOW()
WHERE team_id = $1
`

type SetTeamCallbackParams struct {
	TeamID  string `json:"team_id"`
	Column2 []byte `json:"column_2"`
}

func (q *Queries) SetTeamCallback(ctx context.Context, arg SetTeamCallbackParams) error {
	_, err := q.db.Exec(ctx, setTeamCallback, arg.TeamID, arg.Column2)
	return err
}

const setTeamPermissions = `-- name: SetTeamPermissions :exec
UPDATE "TeamTable"
SET metadata = jsonb_set(COALESCE(metadata, '{}'), '{permissions}', $2::jsonb), updated_at = NOW()
WHERE team_id = $1
`

type SetTeamPermissionsParams struct {
	TeamID  string `json:"team_id"`
	Column2 []byte `json:"column_2"`
}

func (q *Queries) SetTeamPermissions(ctx context.Context, arg SetTeamPermissionsParams) error {
	_, err := q.db.Exec(ctx, setTeamPermissions, arg.TeamID, arg.Column2)
	return err
}

const unblockTeam = `-- name: UnblockTeam :exec
UPDATE "TeamTable"
SET blocked = FALSE, updated_at = NOW()
WHERE team_id = $1
`

func (q *Queries) UnblockTeam(ctx context.Context, teamID string) error {
	_, err := q.db.Exec(ctx, unblockTeam, teamID)
	return err
}

const updateTeam = `-- name: UpdateTeam :one
UPDATE "TeamTable"
SET team_alias = COALESCE($2, team_alias),
    max_budget = COALESCE($3, max_budget),
    models = COALESCE($4, models),
    blocked = COALESCE($5, blocked),
    tpm_limit = COALESCE($6, tpm_limit),
    rpm_limit = COALESCE($7, rpm_limit),
    updated_at = NOW(),
    updated_by = $8
WHERE team_id = $1
RETURNING team_id, team_alias, organization_id, admins, members, members_with_roles, metadata, max_budget, spend, models, blocked, tpm_limit, rpm_limit, budget_duration, budget_reset_at, budget_id, created_at, created_by, updated_at, updated_by
`

type UpdateTeamParams struct {
	TeamID    string   `json:"team_id"`
	TeamAlias *string  `json:"team_alias"`
	MaxBudget *float64 `json:"max_budget"`
	Models    []string `json:"models"`
	Blocked   bool     `json:"blocked"`
	TpmLimit  *int64   `json:"tpm_limit"`
	RpmLimit  *int64   `json:"rpm_limit"`
	UpdatedBy string   `json:"updated_by"`
}

func (q *Queries) UpdateTeam(ctx context.Context, arg UpdateTeamParams) (TeamTable, error) {
	row := q.db.QueryRow(ctx, updateTeam,
		arg.TeamID,
		arg.TeamAlias,
		arg.MaxBudget,
		arg.Models,
		arg.Blocked,
		arg.TpmLimit,
		arg.RpmLimit,
		arg.UpdatedBy,
	)
	var i TeamTable
	err := row.Scan(
		&i.TeamID,
		&i.TeamAlias,
		&i.OrganizationID,
		&i.Admins,
		&i.Members,
		&i.MembersWithRoles,
		&i.Metadata,
		&i.MaxBudget,
		&i.Spend,
		&i.Models,
		&i.Blocked,
		&i.TpmLimit,
		&i.RpmLimit,
		&i.BudgetDuration,
		&i.BudgetResetAt,
		&i.BudgetID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const updateTeamMemberRole = `-- name: UpdateTeamMemberRole :exec
UPDATE "TeamTable"
SET members_with_roles = $2, updated_at = NOW()
WHERE team_id = $1
`

type UpdateTeamMemberRoleParams struct {
	TeamID           string `json:"team_id"`
	MembersWithRoles []byte `json:"members_with_roles"`
}

func (q *Queries) UpdateTeamMemberRole(ctx context.Context, arg UpdateTeamMemberRoleParams) error {
	_, err := q.db.Exec(ctx, updateTeamMemberRole, arg.TeamID, arg.MembersWithRoles)
	return err
}

const updateTeamMetadata = `-- name: UpdateTeamMetadata :exec
UPDATE "TeamTable"
SET metadata = $2, updated_at = NOW()
WHERE team_id = $1
`

type UpdateTeamMetadataParams struct {
	TeamID   string `json:"team_id"`
	Metadata []byte `json:"metadata"`
}

func (q *Queries) UpdateTeamMetadata(ctx context.Context, arg UpdateTeamMetadataParams) error {
	_, err := q.db.Exec(ctx, updateTeamMetadata, arg.TeamID, arg.Metadata)
	return err
}
