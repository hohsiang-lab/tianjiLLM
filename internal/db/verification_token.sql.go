// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: verification_token.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const blockVerificationToken = `-- name: BlockVerificationToken :exec
UPDATE "VerificationToken"
SET blocked = TRUE, updated_at = NOW()
WHERE token = $1
`

func (q *Queries) BlockVerificationToken(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, blockVerificationToken, token)
	return err
}

const bulkUpdateVerificationTokens = `-- name: BulkUpdateVerificationTokens :exec
UPDATE "VerificationToken"
SET max_budget = COALESCE($2, max_budget),
    tpm_limit = COALESCE($3, tpm_limit),
    rpm_limit = COALESCE($4, rpm_limit),
    updated_at = NOW()
WHERE token = ANY($1::text[])
`

type BulkUpdateVerificationTokensParams struct {
	Column1   []string `json:"column_1"`
	MaxBudget *float64 `json:"max_budget"`
	TpmLimit  *int64   `json:"tpm_limit"`
	RpmLimit  *int64   `json:"rpm_limit"`
}

func (q *Queries) BulkUpdateVerificationTokens(ctx context.Context, arg BulkUpdateVerificationTokensParams) error {
	_, err := q.db.Exec(ctx, bulkUpdateVerificationTokens,
		arg.Column1,
		arg.MaxBudget,
		arg.TpmLimit,
		arg.RpmLimit,
	)
	return err
}

const createVerificationToken = `-- name: CreateVerificationToken :one
INSERT INTO "VerificationToken" (
    token, key_name, key_alias, spend, max_budget, expires,
    models, user_id, team_id, organization_id,
    permissions, metadata, tpm_limit, rpm_limit,
    budget_duration, budget_id, created_by
) VALUES (
    $1, $2, $3, $4, $5, $6,
    $7, $8, $9, $10,
    $11, $12, $13, $14,
    $15, $16, $17
)
RETURNING token, key_name, key_alias, spend, max_budget, expires, models, aliases, config, user_id, team_id, organization_id, permissions, metadata, blocked, tpm_limit, rpm_limit, budget_duration, budget_reset_at, allowed_cache_controls, allowed_routes, policies, access_group_ids, model_spend, model_max_budget, soft_budget_cooldown, budget_id, object_permission_id, created_at, created_by, updated_at, updated_by
`

type CreateVerificationTokenParams struct {
	Token          string             `json:"token"`
	KeyName        *string            `json:"key_name"`
	KeyAlias       *string            `json:"key_alias"`
	Spend          float64            `json:"spend"`
	MaxBudget      *float64           `json:"max_budget"`
	Expires        pgtype.Timestamptz `json:"expires"`
	Models         []string           `json:"models"`
	UserID         *string            `json:"user_id"`
	TeamID         *string            `json:"team_id"`
	OrganizationID *string            `json:"organization_id"`
	Permissions    []byte             `json:"permissions"`
	Metadata       []byte             `json:"metadata"`
	TpmLimit       *int64             `json:"tpm_limit"`
	RpmLimit       *int64             `json:"rpm_limit"`
	BudgetDuration *string            `json:"budget_duration"`
	BudgetID       *string            `json:"budget_id"`
	CreatedBy      *string            `json:"created_by"`
}

func (q *Queries) CreateVerificationToken(ctx context.Context, arg CreateVerificationTokenParams) (VerificationToken, error) {
	row := q.db.QueryRow(ctx, createVerificationToken,
		arg.Token,
		arg.KeyName,
		arg.KeyAlias,
		arg.Spend,
		arg.MaxBudget,
		arg.Expires,
		arg.Models,
		arg.UserID,
		arg.TeamID,
		arg.OrganizationID,
		arg.Permissions,
		arg.Metadata,
		arg.TpmLimit,
		arg.RpmLimit,
		arg.BudgetDuration,
		arg.BudgetID,
		arg.CreatedBy,
	)
	var i VerificationToken
	err := row.Scan(
		&i.Token,
		&i.KeyName,
		&i.KeyAlias,
		&i.Spend,
		&i.MaxBudget,
		&i.Expires,
		&i.Models,
		&i.Aliases,
		&i.Config,
		&i.UserID,
		&i.TeamID,
		&i.OrganizationID,
		&i.Permissions,
		&i.Metadata,
		&i.Blocked,
		&i.TpmLimit,
		&i.RpmLimit,
		&i.BudgetDuration,
		&i.BudgetResetAt,
		&i.AllowedCacheControls,
		&i.AllowedRoutes,
		&i.Policies,
		&i.AccessGroupIds,
		&i.ModelSpend,
		&i.ModelMaxBudget,
		&i.SoftBudgetCooldown,
		&i.BudgetID,
		&i.ObjectPermissionID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const deleteVerificationToken = `-- name: DeleteVerificationToken :exec
DELETE FROM "VerificationToken"
WHERE token = $1
`

func (q *Queries) DeleteVerificationToken(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, deleteVerificationToken, token)
	return err
}

const getVerificationToken = `-- name: GetVerificationToken :one
SELECT token, key_name, key_alias, spend, max_budget, expires, models, aliases, config, user_id, team_id, organization_id, permissions, metadata, blocked, tpm_limit, rpm_limit, budget_duration, budget_reset_at, allowed_cache_controls, allowed_routes, policies, access_group_ids, model_spend, model_max_budget, soft_budget_cooldown, budget_id, object_permission_id, created_at, created_by, updated_at, updated_by FROM "VerificationToken"
WHERE token = $1
`

func (q *Queries) GetVerificationToken(ctx context.Context, token string) (VerificationToken, error) {
	row := q.db.QueryRow(ctx, getVerificationToken, token)
	var i VerificationToken
	err := row.Scan(
		&i.Token,
		&i.KeyName,
		&i.KeyAlias,
		&i.Spend,
		&i.MaxBudget,
		&i.Expires,
		&i.Models,
		&i.Aliases,
		&i.Config,
		&i.UserID,
		&i.TeamID,
		&i.OrganizationID,
		&i.Permissions,
		&i.Metadata,
		&i.Blocked,
		&i.TpmLimit,
		&i.RpmLimit,
		&i.BudgetDuration,
		&i.BudgetResetAt,
		&i.AllowedCacheControls,
		&i.AllowedRoutes,
		&i.Policies,
		&i.AccessGroupIds,
		&i.ModelSpend,
		&i.ModelMaxBudget,
		&i.SoftBudgetCooldown,
		&i.BudgetID,
		&i.ObjectPermissionID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const listExpiredTokens = `-- name: ListExpiredTokens :many
SELECT token, key_name, expires FROM "VerificationToken"
WHERE expires IS NOT NULL AND expires <= NOW()
ORDER BY expires
LIMIT 100
`

type ListExpiredTokensRow struct {
	Token   string             `json:"token"`
	KeyName *string            `json:"key_name"`
	Expires pgtype.Timestamptz `json:"expires"`
}

func (q *Queries) ListExpiredTokens(ctx context.Context) ([]ListExpiredTokensRow, error) {
	rows, err := q.db.Query(ctx, listExpiredTokens)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListExpiredTokensRow
	for rows.Next() {
		var i ListExpiredTokensRow
		if err := rows.Scan(&i.Token, &i.KeyName, &i.Expires); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVerificationTokens = `-- name: ListVerificationTokens :many
SELECT token, key_name, key_alias, spend, max_budget, expires, models, aliases, config, user_id, team_id, organization_id, permissions, metadata, blocked, tpm_limit, rpm_limit, budget_duration, budget_reset_at, allowed_cache_controls, allowed_routes, policies, access_group_ids, model_spend, model_max_budget, soft_budget_cooldown, budget_id, object_permission_id, created_at, created_by, updated_at, updated_by FROM "VerificationToken"
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListVerificationTokensParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListVerificationTokens(ctx context.Context, arg ListVerificationTokensParams) ([]VerificationToken, error) {
	rows, err := q.db.Query(ctx, listVerificationTokens, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VerificationToken
	for rows.Next() {
		var i VerificationToken
		if err := rows.Scan(
			&i.Token,
			&i.KeyName,
			&i.KeyAlias,
			&i.Spend,
			&i.MaxBudget,
			&i.Expires,
			&i.Models,
			&i.Aliases,
			&i.Config,
			&i.UserID,
			&i.TeamID,
			&i.OrganizationID,
			&i.Permissions,
			&i.Metadata,
			&i.Blocked,
			&i.TpmLimit,
			&i.RpmLimit,
			&i.BudgetDuration,
			&i.BudgetResetAt,
			&i.AllowedCacheControls,
			&i.AllowedRoutes,
			&i.Policies,
			&i.AccessGroupIds,
			&i.ModelSpend,
			&i.ModelMaxBudget,
			&i.SoftBudgetCooldown,
			&i.BudgetID,
			&i.ObjectPermissionID,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVerificationTokensByTeam = `-- name: ListVerificationTokensByTeam :many
SELECT token, key_name, key_alias, spend, max_budget, expires, models, aliases, config, user_id, team_id, organization_id, permissions, metadata, blocked, tpm_limit, rpm_limit, budget_duration, budget_reset_at, allowed_cache_controls, allowed_routes, policies, access_group_ids, model_spend, model_max_budget, soft_budget_cooldown, budget_id, object_permission_id, created_at, created_by, updated_at, updated_by FROM "VerificationToken"
WHERE team_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListVerificationTokensByTeam(ctx context.Context, teamID *string) ([]VerificationToken, error) {
	rows, err := q.db.Query(ctx, listVerificationTokensByTeam, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VerificationToken
	for rows.Next() {
		var i VerificationToken
		if err := rows.Scan(
			&i.Token,
			&i.KeyName,
			&i.KeyAlias,
			&i.Spend,
			&i.MaxBudget,
			&i.Expires,
			&i.Models,
			&i.Aliases,
			&i.Config,
			&i.UserID,
			&i.TeamID,
			&i.OrganizationID,
			&i.Permissions,
			&i.Metadata,
			&i.Blocked,
			&i.TpmLimit,
			&i.RpmLimit,
			&i.BudgetDuration,
			&i.BudgetResetAt,
			&i.AllowedCacheControls,
			&i.AllowedRoutes,
			&i.Policies,
			&i.AccessGroupIds,
			&i.ModelSpend,
			&i.ModelMaxBudget,
			&i.SoftBudgetCooldown,
			&i.BudgetID,
			&i.ObjectPermissionID,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVerificationTokensByUser = `-- name: ListVerificationTokensByUser :many
SELECT token, key_name, key_alias, spend, max_budget, expires, models, aliases, config, user_id, team_id, organization_id, permissions, metadata, blocked, tpm_limit, rpm_limit, budget_duration, budget_reset_at, allowed_cache_controls, allowed_routes, policies, access_group_ids, model_spend, model_max_budget, soft_budget_cooldown, budget_id, object_permission_id, created_at, created_by, updated_at, updated_by FROM "VerificationToken"
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListVerificationTokensByUser(ctx context.Context, userID *string) ([]VerificationToken, error) {
	rows, err := q.db.Query(ctx, listVerificationTokensByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VerificationToken
	for rows.Next() {
		var i VerificationToken
		if err := rows.Scan(
			&i.Token,
			&i.KeyName,
			&i.KeyAlias,
			&i.Spend,
			&i.MaxBudget,
			&i.Expires,
			&i.Models,
			&i.Aliases,
			&i.Config,
			&i.UserID,
			&i.TeamID,
			&i.OrganizationID,
			&i.Permissions,
			&i.Metadata,
			&i.Blocked,
			&i.TpmLimit,
			&i.RpmLimit,
			&i.BudgetDuration,
			&i.BudgetResetAt,
			&i.AllowedCacheControls,
			&i.AllowedRoutes,
			&i.Policies,
			&i.AccessGroupIds,
			&i.ModelSpend,
			&i.ModelMaxBudget,
			&i.SoftBudgetCooldown,
			&i.BudgetID,
			&i.ObjectPermissionID,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const regenerateVerificationToken = `-- name: RegenerateVerificationToken :one
UPDATE "VerificationToken"
SET token = $2, spend = 0, updated_at = NOW()
WHERE token = $1
RETURNING token, key_name, key_alias, spend, max_budget, expires, models, aliases, config, user_id, team_id, organization_id, permissions, metadata, blocked, tpm_limit, rpm_limit, budget_duration, budget_reset_at, allowed_cache_controls, allowed_routes, policies, access_group_ids, model_spend, model_max_budget, soft_budget_cooldown, budget_id, object_permission_id, created_at, created_by, updated_at, updated_by
`

type RegenerateVerificationTokenParams struct {
	Token   string `json:"token"`
	Token_2 string `json:"token_2"`
}

func (q *Queries) RegenerateVerificationToken(ctx context.Context, arg RegenerateVerificationTokenParams) (VerificationToken, error) {
	row := q.db.QueryRow(ctx, regenerateVerificationToken, arg.Token, arg.Token_2)
	var i VerificationToken
	err := row.Scan(
		&i.Token,
		&i.KeyName,
		&i.KeyAlias,
		&i.Spend,
		&i.MaxBudget,
		&i.Expires,
		&i.Models,
		&i.Aliases,
		&i.Config,
		&i.UserID,
		&i.TeamID,
		&i.OrganizationID,
		&i.Permissions,
		&i.Metadata,
		&i.Blocked,
		&i.TpmLimit,
		&i.RpmLimit,
		&i.BudgetDuration,
		&i.BudgetResetAt,
		&i.AllowedCacheControls,
		&i.AllowedRoutes,
		&i.Policies,
		&i.AccessGroupIds,
		&i.ModelSpend,
		&i.ModelMaxBudget,
		&i.SoftBudgetCooldown,
		&i.BudgetID,
		&i.ObjectPermissionID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const resetBudgetForExpiredTokens = `-- name: ResetBudgetForExpiredTokens :exec
UPDATE "VerificationToken"
SET spend = 0, budget_reset_at = NOW() + (budget_duration || ' seconds')::INTERVAL, updated_at = NOW()
WHERE budget_reset_at IS NOT NULL AND budget_reset_at <= NOW()
`

func (q *Queries) ResetBudgetForExpiredTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, resetBudgetForExpiredTokens)
	return err
}

const resetVerificationTokenSpend = `-- name: ResetVerificationTokenSpend :exec
UPDATE "VerificationToken"
SET spend = 0, updated_at = NOW()
WHERE token = $1
`

func (q *Queries) ResetVerificationTokenSpend(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, resetVerificationTokenSpend, token)
	return err
}

const unblockVerificationToken = `-- name: UnblockVerificationToken :exec
UPDATE "VerificationToken"
SET blocked = FALSE, updated_at = NOW()
WHERE token = $1
`

func (q *Queries) UnblockVerificationToken(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, unblockVerificationToken, token)
	return err
}

const updateVerificationToken = `-- name: UpdateVerificationToken :one
UPDATE "VerificationToken"
SET
    key_name = COALESCE($2, key_name),
    key_alias = COALESCE($3, key_alias),
    max_budget = COALESCE($4, max_budget),
    models = COALESCE($5, models),
    metadata = COALESCE($6, metadata),
    tpm_limit = COALESCE($7, tpm_limit),
    rpm_limit = COALESCE($8, rpm_limit),
    budget_duration = COALESCE($9, budget_duration),
    updated_at = NOW()
WHERE token = $1
RETURNING token, key_name, key_alias, spend, max_budget, expires, models, aliases, config, user_id, team_id, organization_id, permissions, metadata, blocked, tpm_limit, rpm_limit, budget_duration, budget_reset_at, allowed_cache_controls, allowed_routes, policies, access_group_ids, model_spend, model_max_budget, soft_budget_cooldown, budget_id, object_permission_id, created_at, created_by, updated_at, updated_by
`

type UpdateVerificationTokenParams struct {
	Token          string   `json:"token"`
	KeyName        *string  `json:"key_name"`
	KeyAlias       *string  `json:"key_alias"`
	MaxBudget      *float64 `json:"max_budget"`
	Models         []string `json:"models"`
	Metadata       []byte   `json:"metadata"`
	TpmLimit       *int64   `json:"tpm_limit"`
	RpmLimit       *int64   `json:"rpm_limit"`
	BudgetDuration *string  `json:"budget_duration"`
}

func (q *Queries) UpdateVerificationToken(ctx context.Context, arg UpdateVerificationTokenParams) (VerificationToken, error) {
	row := q.db.QueryRow(ctx, updateVerificationToken,
		arg.Token,
		arg.KeyName,
		arg.KeyAlias,
		arg.MaxBudget,
		arg.Models,
		arg.Metadata,
		arg.TpmLimit,
		arg.RpmLimit,
		arg.BudgetDuration,
	)
	var i VerificationToken
	err := row.Scan(
		&i.Token,
		&i.KeyName,
		&i.KeyAlias,
		&i.Spend,
		&i.MaxBudget,
		&i.Expires,
		&i.Models,
		&i.Aliases,
		&i.Config,
		&i.UserID,
		&i.TeamID,
		&i.OrganizationID,
		&i.Permissions,
		&i.Metadata,
		&i.Blocked,
		&i.TpmLimit,
		&i.RpmLimit,
		&i.BudgetDuration,
		&i.BudgetResetAt,
		&i.AllowedCacheControls,
		&i.AllowedRoutes,
		&i.Policies,
		&i.AccessGroupIds,
		&i.ModelSpend,
		&i.ModelMaxBudget,
		&i.SoftBudgetCooldown,
		&i.BudgetID,
		&i.ObjectPermissionID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const updateVerificationTokenSpend = `-- name: UpdateVerificationTokenSpend :exec
UPDATE "VerificationToken"
SET spend = spend + $2, updated_at = NOW()
WHERE token = $1
`

type UpdateVerificationTokenSpendParams struct {
	Token string  `json:"token"`
	Spend float64 `json:"spend"`
}

func (q *Queries) UpdateVerificationTokenSpend(ctx context.Context, arg UpdateVerificationTokenSpendParams) error {
	_, err := q.db.Exec(ctx, updateVerificationTokenSpend, arg.Token, arg.Spend)
	return err
}
