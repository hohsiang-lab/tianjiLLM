// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: verification_token.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const blockVerificationToken = `-- name: BlockVerificationToken :exec
UPDATE "VerificationToken"
SET blocked = TRUE, updated_at = NOW()
WHERE token = $1
`

func (q *Queries) BlockVerificationToken(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, blockVerificationToken, token)
	return err
}

const bulkUpdateVerificationTokens = `-- name: BulkUpdateVerificationTokens :exec
UPDATE "VerificationToken"
SET max_budget = COALESCE($2, max_budget),
    tpm_limit = COALESCE($3, tpm_limit),
    rpm_limit = COALESCE($4, rpm_limit),
    updated_at = NOW()
WHERE token = ANY($1::text[])
`

type BulkUpdateVerificationTokensParams struct {
	Column1   []string `json:"column_1"`
	MaxBudget *float64 `json:"max_budget"`
	TpmLimit  *int64   `json:"tpm_limit"`
	RpmLimit  *int64   `json:"rpm_limit"`
}

func (q *Queries) BulkUpdateVerificationTokens(ctx context.Context, arg BulkUpdateVerificationTokensParams) error {
	_, err := q.db.Exec(ctx, bulkUpdateVerificationTokens,
		arg.Column1,
		arg.MaxBudget,
		arg.TpmLimit,
		arg.RpmLimit,
	)
	return err
}

const countVerificationTokensFiltered = `-- name: CountVerificationTokensFiltered :one
SELECT COUNT(*) FROM "VerificationToken"
WHERE
  ($1::text IS NULL OR team_id = $1) AND
  ($2::text IS NULL OR key_alias = $2) AND
  ($3::text IS NULL OR user_id = $3) AND
  ($4::text IS NULL OR token = $4)
`

type CountVerificationTokensFilteredParams struct {
	FilterTeamID   *string `json:"filter_team_id"`
	FilterKeyAlias *string `json:"filter_key_alias"`
	FilterUserID   *string `json:"filter_user_id"`
	FilterToken    *string `json:"filter_token"`
}

func (q *Queries) CountVerificationTokensFiltered(ctx context.Context, arg CountVerificationTokensFilteredParams) (int64, error) {
	row := q.db.QueryRow(ctx, countVerificationTokensFiltered,
		arg.FilterTeamID,
		arg.FilterKeyAlias,
		arg.FilterUserID,
		arg.FilterToken,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createVerificationToken = `-- name: CreateVerificationToken :one
INSERT INTO "VerificationToken" (
    token, key_name, key_alias, spend, max_budget, expires,
    models, user_id, team_id, organization_id,
    permissions, metadata, tpm_limit, rpm_limit,
    budget_duration, budget_id, created_by
) VALUES (
    $1, $2, $3, $4, $5, $6,
    $7, $8, $9, $10,
    $11, $12, $13, $14,
    $15, $16, $17
)
RETURNING token, key_name, key_alias, spend, max_budget, expires, models, aliases, config, user_id, team_id, organization_id, permissions, metadata, blocked, tpm_limit, rpm_limit, budget_duration, budget_reset_at, allowed_cache_controls, allowed_routes, policies, access_group_ids, model_spend, model_max_budget, soft_budget_cooldown, budget_id, object_permission_id, created_at, created_by, updated_at, updated_by
`

type CreateVerificationTokenParams struct {
	Token          string             `json:"token"`
	KeyName        *string            `json:"key_name"`
	KeyAlias       *string            `json:"key_alias"`
	Spend          float64            `json:"spend"`
	MaxBudget      *float64           `json:"max_budget"`
	Expires        pgtype.Timestamptz `json:"expires"`
	Models         []string           `json:"models"`
	UserID         *string            `json:"user_id"`
	TeamID         *string            `json:"team_id"`
	OrganizationID *string            `json:"organization_id"`
	Permissions    []byte             `json:"permissions"`
	Metadata       []byte             `json:"metadata"`
	TpmLimit       *int64             `json:"tpm_limit"`
	RpmLimit       *int64             `json:"rpm_limit"`
	BudgetDuration *string            `json:"budget_duration"`
	BudgetID       *string            `json:"budget_id"`
	CreatedBy      *string            `json:"created_by"`
}

func (q *Queries) CreateVerificationToken(ctx context.Context, arg CreateVerificationTokenParams) (VerificationToken, error) {
	row := q.db.QueryRow(ctx, createVerificationToken,
		arg.Token,
		arg.KeyName,
		arg.KeyAlias,
		arg.Spend,
		arg.MaxBudget,
		arg.Expires,
		arg.Models,
		arg.UserID,
		arg.TeamID,
		arg.OrganizationID,
		arg.Permissions,
		arg.Metadata,
		arg.TpmLimit,
		arg.RpmLimit,
		arg.BudgetDuration,
		arg.BudgetID,
		arg.CreatedBy,
	)
	var i VerificationToken
	err := row.Scan(
		&i.Token,
		&i.KeyName,
		&i.KeyAlias,
		&i.Spend,
		&i.MaxBudget,
		&i.Expires,
		&i.Models,
		&i.Aliases,
		&i.Config,
		&i.UserID,
		&i.TeamID,
		&i.OrganizationID,
		&i.Permissions,
		&i.Metadata,
		&i.Blocked,
		&i.TpmLimit,
		&i.RpmLimit,
		&i.BudgetDuration,
		&i.BudgetResetAt,
		&i.AllowedCacheControls,
		&i.AllowedRoutes,
		&i.Policies,
		&i.AccessGroupIds,
		&i.ModelSpend,
		&i.ModelMaxBudget,
		&i.SoftBudgetCooldown,
		&i.BudgetID,
		&i.ObjectPermissionID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const deleteVerificationToken = `-- name: DeleteVerificationToken :exec
DELETE FROM "VerificationToken"
WHERE token = $1
`

func (q *Queries) DeleteVerificationToken(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, deleteVerificationToken, token)
	return err
}

const getVerificationToken = `-- name: GetVerificationToken :one
SELECT token, key_name, key_alias, spend, max_budget, expires, models, aliases, config, user_id, team_id, organization_id, permissions, metadata, blocked, tpm_limit, rpm_limit, budget_duration, budget_reset_at, allowed_cache_controls, allowed_routes, policies, access_group_ids, model_spend, model_max_budget, soft_budget_cooldown, budget_id, object_permission_id, created_at, created_by, updated_at, updated_by FROM "VerificationToken"
WHERE token = $1
`

func (q *Queries) GetVerificationToken(ctx context.Context, token string) (VerificationToken, error) {
	row := q.db.QueryRow(ctx, getVerificationToken, token)
	var i VerificationToken
	err := row.Scan(
		&i.Token,
		&i.KeyName,
		&i.KeyAlias,
		&i.Spend,
		&i.MaxBudget,
		&i.Expires,
		&i.Models,
		&i.Aliases,
		&i.Config,
		&i.UserID,
		&i.TeamID,
		&i.OrganizationID,
		&i.Permissions,
		&i.Metadata,
		&i.Blocked,
		&i.TpmLimit,
		&i.RpmLimit,
		&i.BudgetDuration,
		&i.BudgetResetAt,
		&i.AllowedCacheControls,
		&i.AllowedRoutes,
		&i.Policies,
		&i.AccessGroupIds,
		&i.ModelSpend,
		&i.ModelMaxBudget,
		&i.SoftBudgetCooldown,
		&i.BudgetID,
		&i.ObjectPermissionID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const getVerificationTokenByAlias = `-- name: GetVerificationTokenByAlias :one
SELECT token FROM "VerificationToken"
WHERE key_alias = $1 AND ($2::text IS NULL OR team_id = $2)
LIMIT 1
`

type GetVerificationTokenByAliasParams struct {
	Alias        *string `json:"alias"`
	FilterTeamID *string `json:"filter_team_id"`
}

func (q *Queries) GetVerificationTokenByAlias(ctx context.Context, arg GetVerificationTokenByAliasParams) (string, error) {
	row := q.db.QueryRow(ctx, getVerificationTokenByAlias, arg.Alias, arg.FilterTeamID)
	var token string
	err := row.Scan(&token)
	return token, err
}

const listExpiredTokens = `-- name: ListExpiredTokens :many
SELECT token, key_name, expires FROM "VerificationToken"
WHERE expires IS NOT NULL AND expires <= NOW()
ORDER BY expires
LIMIT 100
`

type ListExpiredTokensRow struct {
	Token   string             `json:"token"`
	KeyName *string            `json:"key_name"`
	Expires pgtype.Timestamptz `json:"expires"`
}

func (q *Queries) ListExpiredTokens(ctx context.Context) ([]ListExpiredTokensRow, error) {
	rows, err := q.db.Query(ctx, listExpiredTokens)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListExpiredTokensRow
	for rows.Next() {
		var i ListExpiredTokensRow
		if err := rows.Scan(&i.Token, &i.KeyName, &i.Expires); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVerificationTokens = `-- name: ListVerificationTokens :many
SELECT token, key_name, key_alias, spend, max_budget, expires, models, aliases, config, user_id, team_id, organization_id, permissions, metadata, blocked, tpm_limit, rpm_limit, budget_duration, budget_reset_at, allowed_cache_controls, allowed_routes, policies, access_group_ids, model_spend, model_max_budget, soft_budget_cooldown, budget_id, object_permission_id, created_at, created_by, updated_at, updated_by FROM "VerificationToken"
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListVerificationTokensParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListVerificationTokens(ctx context.Context, arg ListVerificationTokensParams) ([]VerificationToken, error) {
	rows, err := q.db.Query(ctx, listVerificationTokens, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VerificationToken
	for rows.Next() {
		var i VerificationToken
		if err := rows.Scan(
			&i.Token,
			&i.KeyName,
			&i.KeyAlias,
			&i.Spend,
			&i.MaxBudget,
			&i.Expires,
			&i.Models,
			&i.Aliases,
			&i.Config,
			&i.UserID,
			&i.TeamID,
			&i.OrganizationID,
			&i.Permissions,
			&i.Metadata,
			&i.Blocked,
			&i.TpmLimit,
			&i.RpmLimit,
			&i.BudgetDuration,
			&i.BudgetResetAt,
			&i.AllowedCacheControls,
			&i.AllowedRoutes,
			&i.Policies,
			&i.AccessGroupIds,
			&i.ModelSpend,
			&i.ModelMaxBudget,
			&i.SoftBudgetCooldown,
			&i.BudgetID,
			&i.ObjectPermissionID,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVerificationTokensByTeam = `-- name: ListVerificationTokensByTeam :many
SELECT token, key_name, key_alias, spend, max_budget, expires, models, aliases, config, user_id, team_id, organization_id, permissions, metadata, blocked, tpm_limit, rpm_limit, budget_duration, budget_reset_at, allowed_cache_controls, allowed_routes, policies, access_group_ids, model_spend, model_max_budget, soft_budget_cooldown, budget_id, object_permission_id, created_at, created_by, updated_at, updated_by FROM "VerificationToken"
WHERE team_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListVerificationTokensByTeam(ctx context.Context, teamID *string) ([]VerificationToken, error) {
	rows, err := q.db.Query(ctx, listVerificationTokensByTeam, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VerificationToken
	for rows.Next() {
		var i VerificationToken
		if err := rows.Scan(
			&i.Token,
			&i.KeyName,
			&i.KeyAlias,
			&i.Spend,
			&i.MaxBudget,
			&i.Expires,
			&i.Models,
			&i.Aliases,
			&i.Config,
			&i.UserID,
			&i.TeamID,
			&i.OrganizationID,
			&i.Permissions,
			&i.Metadata,
			&i.Blocked,
			&i.TpmLimit,
			&i.RpmLimit,
			&i.BudgetDuration,
			&i.BudgetResetAt,
			&i.AllowedCacheControls,
			&i.AllowedRoutes,
			&i.Policies,
			&i.AccessGroupIds,
			&i.ModelSpend,
			&i.ModelMaxBudget,
			&i.SoftBudgetCooldown,
			&i.BudgetID,
			&i.ObjectPermissionID,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVerificationTokensByUser = `-- name: ListVerificationTokensByUser :many
SELECT token, key_name, key_alias, spend, max_budget, expires, models, aliases, config, user_id, team_id, organization_id, permissions, metadata, blocked, tpm_limit, rpm_limit, budget_duration, budget_reset_at, allowed_cache_controls, allowed_routes, policies, access_group_ids, model_spend, model_max_budget, soft_budget_cooldown, budget_id, object_permission_id, created_at, created_by, updated_at, updated_by FROM "VerificationToken"
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListVerificationTokensByUser(ctx context.Context, userID *string) ([]VerificationToken, error) {
	rows, err := q.db.Query(ctx, listVerificationTokensByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VerificationToken
	for rows.Next() {
		var i VerificationToken
		if err := rows.Scan(
			&i.Token,
			&i.KeyName,
			&i.KeyAlias,
			&i.Spend,
			&i.MaxBudget,
			&i.Expires,
			&i.Models,
			&i.Aliases,
			&i.Config,
			&i.UserID,
			&i.TeamID,
			&i.OrganizationID,
			&i.Permissions,
			&i.Metadata,
			&i.Blocked,
			&i.TpmLimit,
			&i.RpmLimit,
			&i.BudgetDuration,
			&i.BudgetResetAt,
			&i.AllowedCacheControls,
			&i.AllowedRoutes,
			&i.Policies,
			&i.AccessGroupIds,
			&i.ModelSpend,
			&i.ModelMaxBudget,
			&i.SoftBudgetCooldown,
			&i.BudgetID,
			&i.ObjectPermissionID,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVerificationTokensFiltered = `-- name: ListVerificationTokensFiltered :many
SELECT token, key_name, key_alias, spend, max_budget, expires, models, aliases, config, user_id, team_id, organization_id, permissions, metadata, blocked, tpm_limit, rpm_limit, budget_duration, budget_reset_at, allowed_cache_controls, allowed_routes, policies, access_group_ids, model_spend, model_max_budget, soft_budget_cooldown, budget_id, object_permission_id, created_at, created_by, updated_at, updated_by FROM "VerificationToken"
WHERE
  ($1::text IS NULL OR team_id = $1) AND
  ($2::text IS NULL OR key_alias = $2) AND
  ($3::text IS NULL OR user_id = $3) AND
  ($4::text IS NULL OR token = $4)
ORDER BY created_at DESC
LIMIT $6 OFFSET $5
`

type ListVerificationTokensFilteredParams struct {
	FilterTeamID   *string `json:"filter_team_id"`
	FilterKeyAlias *string `json:"filter_key_alias"`
	FilterUserID   *string `json:"filter_user_id"`
	FilterToken    *string `json:"filter_token"`
	QueryOffset    int32   `json:"query_offset"`
	QueryLimit     int32   `json:"query_limit"`
}

func (q *Queries) ListVerificationTokensFiltered(ctx context.Context, arg ListVerificationTokensFilteredParams) ([]VerificationToken, error) {
	rows, err := q.db.Query(ctx, listVerificationTokensFiltered,
		arg.FilterTeamID,
		arg.FilterKeyAlias,
		arg.FilterUserID,
		arg.FilterToken,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VerificationToken
	for rows.Next() {
		var i VerificationToken
		if err := rows.Scan(
			&i.Token,
			&i.KeyName,
			&i.KeyAlias,
			&i.Spend,
			&i.MaxBudget,
			&i.Expires,
			&i.Models,
			&i.Aliases,
			&i.Config,
			&i.UserID,
			&i.TeamID,
			&i.OrganizationID,
			&i.Permissions,
			&i.Metadata,
			&i.Blocked,
			&i.TpmLimit,
			&i.RpmLimit,
			&i.BudgetDuration,
			&i.BudgetResetAt,
			&i.AllowedCacheControls,
			&i.AllowedRoutes,
			&i.Policies,
			&i.AccessGroupIds,
			&i.ModelSpend,
			&i.ModelMaxBudget,
			&i.SoftBudgetCooldown,
			&i.BudgetID,
			&i.ObjectPermissionID,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const regenerateVerificationToken = `-- name: RegenerateVerificationToken :one
UPDATE "VerificationToken"
SET token = $2, spend = 0, updated_at = NOW()
WHERE token = $1
RETURNING token, key_name, key_alias, spend, max_budget, expires, models, aliases, config, user_id, team_id, organization_id, permissions, metadata, blocked, tpm_limit, rpm_limit, budget_duration, budget_reset_at, allowed_cache_controls, allowed_routes, policies, access_group_ids, model_spend, model_max_budget, soft_budget_cooldown, budget_id, object_permission_id, created_at, created_by, updated_at, updated_by
`

type RegenerateVerificationTokenParams struct {
	Token   string `json:"token"`
	Token_2 string `json:"token_2"`
}

func (q *Queries) RegenerateVerificationToken(ctx context.Context, arg RegenerateVerificationTokenParams) (VerificationToken, error) {
	row := q.db.QueryRow(ctx, regenerateVerificationToken, arg.Token, arg.Token_2)
	var i VerificationToken
	err := row.Scan(
		&i.Token,
		&i.KeyName,
		&i.KeyAlias,
		&i.Spend,
		&i.MaxBudget,
		&i.Expires,
		&i.Models,
		&i.Aliases,
		&i.Config,
		&i.UserID,
		&i.TeamID,
		&i.OrganizationID,
		&i.Permissions,
		&i.Metadata,
		&i.Blocked,
		&i.TpmLimit,
		&i.RpmLimit,
		&i.BudgetDuration,
		&i.BudgetResetAt,
		&i.AllowedCacheControls,
		&i.AllowedRoutes,
		&i.Policies,
		&i.AccessGroupIds,
		&i.ModelSpend,
		&i.ModelMaxBudget,
		&i.SoftBudgetCooldown,
		&i.BudgetID,
		&i.ObjectPermissionID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const regenerateVerificationTokenWithParams = `-- name: RegenerateVerificationTokenWithParams :one
UPDATE "VerificationToken"
SET
    token = $1,
    spend = 0,
    max_budget = COALESCE($2, max_budget),
    tpm_limit = COALESCE($3, tpm_limit),
    rpm_limit = COALESCE($4, rpm_limit),
    budget_duration = COALESCE($5, budget_duration),
    updated_at = NOW()
WHERE token = $6
RETURNING token, key_name, key_alias, spend, max_budget, expires, models, aliases, config, user_id, team_id, organization_id, permissions, metadata, blocked, tpm_limit, rpm_limit, budget_duration, budget_reset_at, allowed_cache_controls, allowed_routes, policies, access_group_ids, model_spend, model_max_budget, soft_budget_cooldown, budget_id, object_permission_id, created_at, created_by, updated_at, updated_by
`

type RegenerateVerificationTokenWithParamsParams struct {
	NewToken          string   `json:"new_token"`
	NewMaxBudget      *float64 `json:"new_max_budget"`
	NewTpmLimit       *int64   `json:"new_tpm_limit"`
	NewRpmLimit       *int64   `json:"new_rpm_limit"`
	NewBudgetDuration *string  `json:"new_budget_duration"`
	OldToken          string   `json:"old_token"`
}

func (q *Queries) RegenerateVerificationTokenWithParams(ctx context.Context, arg RegenerateVerificationTokenWithParamsParams) (VerificationToken, error) {
	row := q.db.QueryRow(ctx, regenerateVerificationTokenWithParams,
		arg.NewToken,
		arg.NewMaxBudget,
		arg.NewTpmLimit,
		arg.NewRpmLimit,
		arg.NewBudgetDuration,
		arg.OldToken,
	)
	var i VerificationToken
	err := row.Scan(
		&i.Token,
		&i.KeyName,
		&i.KeyAlias,
		&i.Spend,
		&i.MaxBudget,
		&i.Expires,
		&i.Models,
		&i.Aliases,
		&i.Config,
		&i.UserID,
		&i.TeamID,
		&i.OrganizationID,
		&i.Permissions,
		&i.Metadata,
		&i.Blocked,
		&i.TpmLimit,
		&i.RpmLimit,
		&i.BudgetDuration,
		&i.BudgetResetAt,
		&i.AllowedCacheControls,
		&i.AllowedRoutes,
		&i.Policies,
		&i.AccessGroupIds,
		&i.ModelSpend,
		&i.ModelMaxBudget,
		&i.SoftBudgetCooldown,
		&i.BudgetID,
		&i.ObjectPermissionID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const resetBudgetForExpiredTokens = `-- name: ResetBudgetForExpiredTokens :exec
UPDATE "VerificationToken"
SET spend = 0, budget_reset_at = NOW() + (budget_duration || ' seconds')::INTERVAL, updated_at = NOW()
WHERE budget_reset_at IS NOT NULL AND budget_reset_at <= NOW()
`

func (q *Queries) ResetBudgetForExpiredTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, resetBudgetForExpiredTokens)
	return err
}

const resetVerificationTokenSpend = `-- name: ResetVerificationTokenSpend :exec
UPDATE "VerificationToken"
SET spend = 0, updated_at = NOW()
WHERE token = $1
`

func (q *Queries) ResetVerificationTokenSpend(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, resetVerificationTokenSpend, token)
	return err
}

const unblockVerificationToken = `-- name: UnblockVerificationToken :exec
UPDATE "VerificationToken"
SET blocked = FALSE, updated_at = NOW()
WHERE token = $1
`

func (q *Queries) UnblockVerificationToken(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, unblockVerificationToken, token)
	return err
}

const updateVerificationToken = `-- name: UpdateVerificationToken :one
UPDATE "VerificationToken"
SET
    key_name = COALESCE($2, key_name),
    key_alias = COALESCE($3, key_alias),
    max_budget = COALESCE($4, max_budget),
    models = COALESCE($5, models),
    metadata = COALESCE($6, metadata),
    tpm_limit = COALESCE($7, tpm_limit),
    rpm_limit = COALESCE($8, rpm_limit),
    budget_duration = COALESCE($9, budget_duration),
    updated_at = NOW()
WHERE token = $1
RETURNING token, key_name, key_alias, spend, max_budget, expires, models, aliases, config, user_id, team_id, organization_id, permissions, metadata, blocked, tpm_limit, rpm_limit, budget_duration, budget_reset_at, allowed_cache_controls, allowed_routes, policies, access_group_ids, model_spend, model_max_budget, soft_budget_cooldown, budget_id, object_permission_id, created_at, created_by, updated_at, updated_by
`

type UpdateVerificationTokenParams struct {
	Token          string   `json:"token"`
	KeyName        *string  `json:"key_name"`
	KeyAlias       *string  `json:"key_alias"`
	MaxBudget      *float64 `json:"max_budget"`
	Models         []string `json:"models"`
	Metadata       []byte   `json:"metadata"`
	TpmLimit       *int64   `json:"tpm_limit"`
	RpmLimit       *int64   `json:"rpm_limit"`
	BudgetDuration *string  `json:"budget_duration"`
}

func (q *Queries) UpdateVerificationToken(ctx context.Context, arg UpdateVerificationTokenParams) (VerificationToken, error) {
	row := q.db.QueryRow(ctx, updateVerificationToken,
		arg.Token,
		arg.KeyName,
		arg.KeyAlias,
		arg.MaxBudget,
		arg.Models,
		arg.Metadata,
		arg.TpmLimit,
		arg.RpmLimit,
		arg.BudgetDuration,
	)
	var i VerificationToken
	err := row.Scan(
		&i.Token,
		&i.KeyName,
		&i.KeyAlias,
		&i.Spend,
		&i.MaxBudget,
		&i.Expires,
		&i.Models,
		&i.Aliases,
		&i.Config,
		&i.UserID,
		&i.TeamID,
		&i.OrganizationID,
		&i.Permissions,
		&i.Metadata,
		&i.Blocked,
		&i.TpmLimit,
		&i.RpmLimit,
		&i.BudgetDuration,
		&i.BudgetResetAt,
		&i.AllowedCacheControls,
		&i.AllowedRoutes,
		&i.Policies,
		&i.AccessGroupIds,
		&i.ModelSpend,
		&i.ModelMaxBudget,
		&i.SoftBudgetCooldown,
		&i.BudgetID,
		&i.ObjectPermissionID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const updateVerificationTokenSpend = `-- name: UpdateVerificationTokenSpend :exec
UPDATE "VerificationToken"
SET spend = spend + $2, updated_at = NOW()
WHERE token = $1
`

type UpdateVerificationTokenSpendParams struct {
	Token string  `json:"token"`
	Spend float64 `json:"spend"`
}

func (q *Queries) UpdateVerificationTokenSpend(ctx context.Context, arg UpdateVerificationTokenSpendParams) error {
	_, err := q.db.Exec(ctx, updateVerificationTokenSpend, arg.Token, arg.Spend)
	return err
}
