// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: agent.sql

package db

import (
	"context"
)

const createAgent = `-- name: CreateAgent :one
INSERT INTO "AgentsTable" (
    agent_name, tianji_params, agent_card_params,
    agent_access_groups, created_by
) VALUES ($1, $2, $3, $4, $5)
RETURNING agent_id, agent_name, tianji_params, agent_card_params, agent_access_groups, created_at, created_by, updated_at, updated_by
`

type CreateAgentParams struct {
	AgentName         string   `json:"agent_name"`
	TianjiParams      []byte   `json:"tianji_params"`
	AgentCardParams   []byte   `json:"agent_card_params"`
	AgentAccessGroups []string `json:"agent_access_groups"`
	CreatedBy         string   `json:"created_by"`
}

func (q *Queries) CreateAgent(ctx context.Context, arg CreateAgentParams) (AgentsTable, error) {
	row := q.db.QueryRow(ctx, createAgent,
		arg.AgentName,
		arg.TianjiParams,
		arg.AgentCardParams,
		arg.AgentAccessGroups,
		arg.CreatedBy,
	)
	var i AgentsTable
	err := row.Scan(
		&i.AgentID,
		&i.AgentName,
		&i.TianjiParams,
		&i.AgentCardParams,
		&i.AgentAccessGroups,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const deleteAgent = `-- name: DeleteAgent :exec
DELETE FROM "AgentsTable"
WHERE agent_id = $1
`

func (q *Queries) DeleteAgent(ctx context.Context, agentID string) error {
	_, err := q.db.Exec(ctx, deleteAgent, agentID)
	return err
}

const getAgent = `-- name: GetAgent :one
SELECT agent_id, agent_name, tianji_params, agent_card_params, agent_access_groups, created_at, created_by, updated_at, updated_by FROM "AgentsTable"
WHERE agent_id = $1
`

func (q *Queries) GetAgent(ctx context.Context, agentID string) (AgentsTable, error) {
	row := q.db.QueryRow(ctx, getAgent, agentID)
	var i AgentsTable
	err := row.Scan(
		&i.AgentID,
		&i.AgentName,
		&i.TianjiParams,
		&i.AgentCardParams,
		&i.AgentAccessGroups,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const getAgentByName = `-- name: GetAgentByName :one
SELECT agent_id, agent_name, tianji_params, agent_card_params, agent_access_groups, created_at, created_by, updated_at, updated_by FROM "AgentsTable"
WHERE agent_name = $1
`

func (q *Queries) GetAgentByName(ctx context.Context, agentName string) (AgentsTable, error) {
	row := q.db.QueryRow(ctx, getAgentByName, agentName)
	var i AgentsTable
	err := row.Scan(
		&i.AgentID,
		&i.AgentName,
		&i.TianjiParams,
		&i.AgentCardParams,
		&i.AgentAccessGroups,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const listAgents = `-- name: ListAgents :many
SELECT agent_id, agent_name, tianji_params, agent_card_params, agent_access_groups, created_at, created_by, updated_at, updated_by FROM "AgentsTable"
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListAgentsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAgents(ctx context.Context, arg ListAgentsParams) ([]AgentsTable, error) {
	rows, err := q.db.Query(ctx, listAgents, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AgentsTable
	for rows.Next() {
		var i AgentsTable
		if err := rows.Scan(
			&i.AgentID,
			&i.AgentName,
			&i.TianjiParams,
			&i.AgentCardParams,
			&i.AgentAccessGroups,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAgentsByAccessGroups = `-- name: ListAgentsByAccessGroups :many
SELECT agent_id, agent_name, tianji_params, agent_card_params, agent_access_groups, created_at, created_by, updated_at, updated_by FROM "AgentsTable"
WHERE agent_access_groups && $1::text[]
ORDER BY created_at DESC
`

func (q *Queries) ListAgentsByAccessGroups(ctx context.Context, dollar_1 []string) ([]AgentsTable, error) {
	rows, err := q.db.Query(ctx, listAgentsByAccessGroups, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AgentsTable
	for rows.Next() {
		var i AgentsTable
		if err := rows.Scan(
			&i.AgentID,
			&i.AgentName,
			&i.TianjiParams,
			&i.AgentCardParams,
			&i.AgentAccessGroups,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const patchAgent = `-- name: PatchAgent :one
UPDATE "AgentsTable"
SET
    agent_name = COALESCE($2, agent_name),
    tianji_params = COALESCE($3, tianji_params),
    agent_card_params = COALESCE($4, agent_card_params),
    agent_access_groups = COALESCE($5, agent_access_groups),
    updated_by = COALESCE($6, updated_by),
    updated_at = NOW()
WHERE agent_id = $1
RETURNING agent_id, agent_name, tianji_params, agent_card_params, agent_access_groups, created_at, created_by, updated_at, updated_by
`

type PatchAgentParams struct {
	AgentID           string   `json:"agent_id"`
	AgentName         string   `json:"agent_name"`
	TianjiParams      []byte   `json:"tianji_params"`
	AgentCardParams   []byte   `json:"agent_card_params"`
	AgentAccessGroups []string `json:"agent_access_groups"`
	UpdatedBy         string   `json:"updated_by"`
}

func (q *Queries) PatchAgent(ctx context.Context, arg PatchAgentParams) (AgentsTable, error) {
	row := q.db.QueryRow(ctx, patchAgent,
		arg.AgentID,
		arg.AgentName,
		arg.TianjiParams,
		arg.AgentCardParams,
		arg.AgentAccessGroups,
		arg.UpdatedBy,
	)
	var i AgentsTable
	err := row.Scan(
		&i.AgentID,
		&i.AgentName,
		&i.TianjiParams,
		&i.AgentCardParams,
		&i.AgentAccessGroups,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const updateAgent = `-- name: UpdateAgent :one
UPDATE "AgentsTable"
SET
    agent_name = $2,
    tianji_params = $3,
    agent_card_params = $4,
    agent_access_groups = $5,
    updated_by = $6,
    updated_at = NOW()
WHERE agent_id = $1
RETURNING agent_id, agent_name, tianji_params, agent_card_params, agent_access_groups, created_at, created_by, updated_at, updated_by
`

type UpdateAgentParams struct {
	AgentID           string   `json:"agent_id"`
	AgentName         string   `json:"agent_name"`
	TianjiParams      []byte   `json:"tianji_params"`
	AgentCardParams   []byte   `json:"agent_card_params"`
	AgentAccessGroups []string `json:"agent_access_groups"`
	UpdatedBy         string   `json:"updated_by"`
}

func (q *Queries) UpdateAgent(ctx context.Context, arg UpdateAgentParams) (AgentsTable, error) {
	row := q.db.QueryRow(ctx, updateAgent,
		arg.AgentID,
		arg.AgentName,
		arg.TianjiParams,
		arg.AgentCardParams,
		arg.AgentAccessGroups,
		arg.UpdatedBy,
	)
	var i AgentsTable
	err := row.Scan(
		&i.AgentID,
		&i.AgentName,
		&i.TianjiParams,
		&i.AgentCardParams,
		&i.AgentAccessGroups,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}
