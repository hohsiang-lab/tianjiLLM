// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: customer_mgmt.sql

package db

import (
	"context"
)

const blockEndUser = `-- name: BlockEndUser :one
UPDATE "EndUserTable2" SET blocked = TRUE, updated_at = NOW()
WHERE id = $1
RETURNING id, end_user_id, alias, allowed_model_region, default_model, budget, blocked, metadata, created_at, updated_at
`

func (q *Queries) BlockEndUser(ctx context.Context, id string) (EndUserTable2, error) {
	row := q.db.QueryRow(ctx, blockEndUser, id)
	var i EndUserTable2
	err := row.Scan(
		&i.ID,
		&i.EndUserID,
		&i.Alias,
		&i.AllowedModelRegion,
		&i.DefaultModel,
		&i.Budget,
		&i.Blocked,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createEndUser = `-- name: CreateEndUser :one
INSERT INTO "EndUserTable2" (end_user_id, alias, allowed_model_region, default_model, budget, blocked, metadata)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, end_user_id, alias, allowed_model_region, default_model, budget, blocked, metadata, created_at, updated_at
`

type CreateEndUserParams struct {
	EndUserID          string   `json:"end_user_id"`
	Alias              *string  `json:"alias"`
	AllowedModelRegion *string  `json:"allowed_model_region"`
	DefaultModel       *string  `json:"default_model"`
	Budget             *float64 `json:"budget"`
	Blocked            bool     `json:"blocked"`
	Metadata           []byte   `json:"metadata"`
}

func (q *Queries) CreateEndUser(ctx context.Context, arg CreateEndUserParams) (EndUserTable2, error) {
	row := q.db.QueryRow(ctx, createEndUser,
		arg.EndUserID,
		arg.Alias,
		arg.AllowedModelRegion,
		arg.DefaultModel,
		arg.Budget,
		arg.Blocked,
		arg.Metadata,
	)
	var i EndUserTable2
	err := row.Scan(
		&i.ID,
		&i.EndUserID,
		&i.Alias,
		&i.AllowedModelRegion,
		&i.DefaultModel,
		&i.Budget,
		&i.Blocked,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteEndUser = `-- name: DeleteEndUser :exec
DELETE FROM "EndUserTable2" WHERE id = $1
`

func (q *Queries) DeleteEndUser(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteEndUser, id)
	return err
}

const getEndUser = `-- name: GetEndUser :one
SELECT id, end_user_id, alias, allowed_model_region, default_model, budget, blocked, metadata, created_at, updated_at FROM "EndUserTable2" WHERE id = $1
`

func (q *Queries) GetEndUser(ctx context.Context, id string) (EndUserTable2, error) {
	row := q.db.QueryRow(ctx, getEndUser, id)
	var i EndUserTable2
	err := row.Scan(
		&i.ID,
		&i.EndUserID,
		&i.Alias,
		&i.AllowedModelRegion,
		&i.DefaultModel,
		&i.Budget,
		&i.Blocked,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEndUserByExternalID = `-- name: GetEndUserByExternalID :one
SELECT id, end_user_id, alias, allowed_model_region, default_model, budget, blocked, metadata, created_at, updated_at FROM "EndUserTable2" WHERE end_user_id = $1
`

func (q *Queries) GetEndUserByExternalID(ctx context.Context, endUserID string) (EndUserTable2, error) {
	row := q.db.QueryRow(ctx, getEndUserByExternalID, endUserID)
	var i EndUserTable2
	err := row.Scan(
		&i.ID,
		&i.EndUserID,
		&i.Alias,
		&i.AllowedModelRegion,
		&i.DefaultModel,
		&i.Budget,
		&i.Blocked,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listEndUsers = `-- name: ListEndUsers :many
SELECT id, end_user_id, alias, allowed_model_region, default_model, budget, blocked, metadata, created_at, updated_at FROM "EndUserTable2" ORDER BY created_at DESC
`

func (q *Queries) ListEndUsers(ctx context.Context) ([]EndUserTable2, error) {
	rows, err := q.db.Query(ctx, listEndUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EndUserTable2
	for rows.Next() {
		var i EndUserTable2
		if err := rows.Scan(
			&i.ID,
			&i.EndUserID,
			&i.Alias,
			&i.AllowedModelRegion,
			&i.DefaultModel,
			&i.Budget,
			&i.Blocked,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unblockEndUser = `-- name: UnblockEndUser :one
UPDATE "EndUserTable2" SET blocked = FALSE, updated_at = NOW()
WHERE id = $1
RETURNING id, end_user_id, alias, allowed_model_region, default_model, budget, blocked, metadata, created_at, updated_at
`

func (q *Queries) UnblockEndUser(ctx context.Context, id string) (EndUserTable2, error) {
	row := q.db.QueryRow(ctx, unblockEndUser, id)
	var i EndUserTable2
	err := row.Scan(
		&i.ID,
		&i.EndUserID,
		&i.Alias,
		&i.AllowedModelRegion,
		&i.DefaultModel,
		&i.Budget,
		&i.Blocked,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateEndUser = `-- name: UpdateEndUser :one
UPDATE "EndUserTable2"
SET alias = COALESCE($2, alias),
    allowed_model_region = COALESCE($3, allowed_model_region),
    default_model = COALESCE($4, default_model),
    budget = COALESCE($5, budget),
    metadata = COALESCE($6, metadata),
    updated_at = NOW()
WHERE id = $1
RETURNING id, end_user_id, alias, allowed_model_region, default_model, budget, blocked, metadata, created_at, updated_at
`

type UpdateEndUserParams struct {
	ID                 string   `json:"id"`
	Alias              *string  `json:"alias"`
	AllowedModelRegion *string  `json:"allowed_model_region"`
	DefaultModel       *string  `json:"default_model"`
	Budget             *float64 `json:"budget"`
	Metadata           []byte   `json:"metadata"`
}

func (q *Queries) UpdateEndUser(ctx context.Context, arg UpdateEndUserParams) (EndUserTable2, error) {
	row := q.db.QueryRow(ctx, updateEndUser,
		arg.ID,
		arg.Alias,
		arg.AllowedModelRegion,
		arg.DefaultModel,
		arg.Budget,
		arg.Metadata,
	)
	var i EndUserTable2
	err := row.Scan(
		&i.ID,
		&i.EndUserID,
		&i.Alias,
		&i.AllowedModelRegion,
		&i.DefaultModel,
		&i.Budget,
		&i.Blocked,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
