// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user.sql

package db

import (
	"context"
)

const createUser = `-- name: CreateUser :one
INSERT INTO "UserTable" (user_id, user_alias, user_email, user_role, teams, max_budget, models, tpm_limit, rpm_limit, budget_duration, created_by)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING user_id, user_alias, user_email, user_role, teams, max_budget, spend, models, metadata, tpm_limit, rpm_limit, budget_duration, budget_reset_at, budget_id, created_at, created_by, updated_at, updated_by
`

type CreateUserParams struct {
	UserID         string   `json:"user_id"`
	UserAlias      *string  `json:"user_alias"`
	UserEmail      *string  `json:"user_email"`
	UserRole       string   `json:"user_role"`
	Teams          []string `json:"teams"`
	MaxBudget      *float64 `json:"max_budget"`
	Models         []string `json:"models"`
	TpmLimit       *int64   `json:"tpm_limit"`
	RpmLimit       *int64   `json:"rpm_limit"`
	BudgetDuration *string  `json:"budget_duration"`
	CreatedBy      string   `json:"created_by"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (UserTable, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.UserID,
		arg.UserAlias,
		arg.UserEmail,
		arg.UserRole,
		arg.Teams,
		arg.MaxBudget,
		arg.Models,
		arg.TpmLimit,
		arg.RpmLimit,
		arg.BudgetDuration,
		arg.CreatedBy,
	)
	var i UserTable
	err := row.Scan(
		&i.UserID,
		&i.UserAlias,
		&i.UserEmail,
		&i.UserRole,
		&i.Teams,
		&i.MaxBudget,
		&i.Spend,
		&i.Models,
		&i.Metadata,
		&i.TpmLimit,
		&i.RpmLimit,
		&i.BudgetDuration,
		&i.BudgetResetAt,
		&i.BudgetID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM "UserTable" WHERE user_id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, userID string) error {
	_, err := q.db.Exec(ctx, deleteUser, userID)
	return err
}

const getUser = `-- name: GetUser :one
SELECT user_id, user_alias, user_email, user_role, teams, max_budget, spend, models, metadata, tpm_limit, rpm_limit, budget_duration, budget_reset_at, budget_id, created_at, created_by, updated_at, updated_by FROM "UserTable" WHERE user_id = $1
`

func (q *Queries) GetUser(ctx context.Context, userID string) (UserTable, error) {
	row := q.db.QueryRow(ctx, getUser, userID)
	var i UserTable
	err := row.Scan(
		&i.UserID,
		&i.UserAlias,
		&i.UserEmail,
		&i.UserRole,
		&i.Teams,
		&i.MaxBudget,
		&i.Spend,
		&i.Models,
		&i.Metadata,
		&i.TpmLimit,
		&i.RpmLimit,
		&i.BudgetDuration,
		&i.BudgetResetAt,
		&i.BudgetID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT user_id, user_alias, user_email, user_role, teams, max_budget, spend, models, metadata, tpm_limit, rpm_limit, budget_duration, budget_reset_at, budget_id, created_at, created_by, updated_at, updated_by FROM "UserTable" WHERE user_email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, userEmail *string) (UserTable, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, userEmail)
	var i UserTable
	err := row.Scan(
		&i.UserID,
		&i.UserAlias,
		&i.UserEmail,
		&i.UserRole,
		&i.Teams,
		&i.MaxBudget,
		&i.Spend,
		&i.Models,
		&i.Metadata,
		&i.TpmLimit,
		&i.RpmLimit,
		&i.BudgetDuration,
		&i.BudgetResetAt,
		&i.BudgetID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const listUsers = `-- name: ListUsers :many
SELECT user_id, user_alias, user_email, user_role, teams, max_budget, spend, models, metadata, tpm_limit, rpm_limit, budget_duration, budget_reset_at, budget_id, created_at, created_by, updated_at, updated_by FROM "UserTable" ORDER BY created_at DESC
`

func (q *Queries) ListUsers(ctx context.Context) ([]UserTable, error) {
	rows, err := q.db.Query(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTable
	for rows.Next() {
		var i UserTable
		if err := rows.Scan(
			&i.UserID,
			&i.UserAlias,
			&i.UserEmail,
			&i.UserRole,
			&i.Teams,
			&i.MaxBudget,
			&i.Spend,
			&i.Models,
			&i.Metadata,
			&i.TpmLimit,
			&i.RpmLimit,
			&i.BudgetDuration,
			&i.BudgetResetAt,
			&i.BudgetID,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUser = `-- name: UpdateUser :one
UPDATE "UserTable"
SET user_alias = COALESCE($2, user_alias),
    user_email = COALESCE($3, user_email),
    user_role = COALESCE($4, user_role),
    max_budget = COALESCE($5, max_budget),
    models = COALESCE($6, models),
    tpm_limit = COALESCE($7, tpm_limit),
    rpm_limit = COALESCE($8, rpm_limit),
    updated_at = NOW(),
    updated_by = $9
WHERE user_id = $1
RETURNING user_id, user_alias, user_email, user_role, teams, max_budget, spend, models, metadata, tpm_limit, rpm_limit, budget_duration, budget_reset_at, budget_id, created_at, created_by, updated_at, updated_by
`

type UpdateUserParams struct {
	UserID    string   `json:"user_id"`
	UserAlias *string  `json:"user_alias"`
	UserEmail *string  `json:"user_email"`
	UserRole  string   `json:"user_role"`
	MaxBudget *float64 `json:"max_budget"`
	Models    []string `json:"models"`
	TpmLimit  *int64   `json:"tpm_limit"`
	RpmLimit  *int64   `json:"rpm_limit"`
	UpdatedBy string   `json:"updated_by"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (UserTable, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.UserID,
		arg.UserAlias,
		arg.UserEmail,
		arg.UserRole,
		arg.MaxBudget,
		arg.Models,
		arg.TpmLimit,
		arg.RpmLimit,
		arg.UpdatedBy,
	)
	var i UserTable
	err := row.Scan(
		&i.UserID,
		&i.UserAlias,
		&i.UserEmail,
		&i.UserRole,
		&i.Teams,
		&i.MaxBudget,
		&i.Spend,
		&i.Models,
		&i.Metadata,
		&i.TpmLimit,
		&i.RpmLimit,
		&i.BudgetDuration,
		&i.BudgetResetAt,
		&i.BudgetID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const updateUserMetadata = `-- name: UpdateUserMetadata :exec
UPDATE "UserTable"
SET metadata = $2, updated_at = NOW()
WHERE user_id = $1
`

type UpdateUserMetadataParams struct {
	UserID   string `json:"user_id"`
	Metadata []byte `json:"metadata"`
}

func (q *Queries) UpdateUserMetadata(ctx context.Context, arg UpdateUserMetadataParams) error {
	_, err := q.db.Exec(ctx, updateUserMetadata, arg.UserID, arg.Metadata)
	return err
}
