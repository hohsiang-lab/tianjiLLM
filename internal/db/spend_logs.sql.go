// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: spend_logs.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSpendLog = `-- name: CreateSpendLog :exec
INSERT INTO "SpendLogs" (request_id, call_type, api_key, spend, total_tokens, prompt_tokens, completion_tokens, starttime, endtime, model, model_id, model_group, api_base, "user", metadata, cache_hit, cache_key, request_tags, team_id, end_user, requester_ip_address)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21)
`

type CreateSpendLogParams struct {
	RequestID          string             `json:"request_id"`
	CallType           string             `json:"call_type"`
	ApiKey             string             `json:"api_key"`
	Spend              float64            `json:"spend"`
	TotalTokens        int32              `json:"total_tokens"`
	PromptTokens       int32              `json:"prompt_tokens"`
	CompletionTokens   int32              `json:"completion_tokens"`
	Starttime          pgtype.Timestamptz `json:"starttime"`
	Endtime            pgtype.Timestamptz `json:"endtime"`
	Model              string             `json:"model"`
	ModelID            string             `json:"model_id"`
	ModelGroup         string             `json:"model_group"`
	ApiBase            string             `json:"api_base"`
	User               string             `json:"user"`
	Metadata           []byte             `json:"metadata"`
	CacheHit           string             `json:"cache_hit"`
	CacheKey           string             `json:"cache_key"`
	RequestTags        []string           `json:"request_tags"`
	TeamID             *string            `json:"team_id"`
	EndUser            *string            `json:"end_user"`
	RequesterIpAddress *string            `json:"requester_ip_address"`
}

func (q *Queries) CreateSpendLog(ctx context.Context, arg CreateSpendLogParams) error {
	_, err := q.db.Exec(ctx, createSpendLog,
		arg.RequestID,
		arg.CallType,
		arg.ApiKey,
		arg.Spend,
		arg.TotalTokens,
		arg.PromptTokens,
		arg.CompletionTokens,
		arg.Starttime,
		arg.Endtime,
		arg.Model,
		arg.ModelID,
		arg.ModelGroup,
		arg.ApiBase,
		arg.User,
		arg.Metadata,
		arg.CacheHit,
		arg.CacheKey,
		arg.RequestTags,
		arg.TeamID,
		arg.EndUser,
		arg.RequesterIpAddress,
	)
	return err
}

const deleteOldSpendLogs = `-- name: DeleteOldSpendLogs :exec
DELETE FROM "SpendLogs"
WHERE starttime < $1
`

func (q *Queries) DeleteOldSpendLogs(ctx context.Context, starttime pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteOldSpendLogs, starttime)
	return err
}

const getSpendByEndUser = `-- name: GetSpendByEndUser :many
SELECT end_user, SUM(spend) as total_spend, SUM(total_tokens) as total_tokens
FROM "SpendLogs"
WHERE end_user IS NOT NULL AND end_user != '' AND starttime >= $1
GROUP BY end_user
ORDER BY total_spend DESC
`

type GetSpendByEndUserRow struct {
	EndUser     *string `json:"end_user"`
	TotalSpend  int64   `json:"total_spend"`
	TotalTokens int64   `json:"total_tokens"`
}

func (q *Queries) GetSpendByEndUser(ctx context.Context, starttime pgtype.Timestamptz) ([]GetSpendByEndUserRow, error) {
	rows, err := q.db.Query(ctx, getSpendByEndUser, starttime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSpendByEndUserRow
	for rows.Next() {
		var i GetSpendByEndUserRow
		if err := rows.Scan(&i.EndUser, &i.TotalSpend, &i.TotalTokens); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpendByKey = `-- name: GetSpendByKey :many
SELECT api_key, SUM(spend) as total_spend, SUM(total_tokens) as total_tokens
FROM "SpendLogs"
WHERE api_key = ANY($1::text[])
AND starttime >= $2
GROUP BY api_key
`

type GetSpendByKeyParams struct {
	Column1   []string           `json:"column_1"`
	Starttime pgtype.Timestamptz `json:"starttime"`
}

type GetSpendByKeyRow struct {
	ApiKey      string `json:"api_key"`
	TotalSpend  int64  `json:"total_spend"`
	TotalTokens int64  `json:"total_tokens"`
}

func (q *Queries) GetSpendByKey(ctx context.Context, arg GetSpendByKeyParams) ([]GetSpendByKeyRow, error) {
	rows, err := q.db.Query(ctx, getSpendByKey, arg.Column1, arg.Starttime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSpendByKeyRow
	for rows.Next() {
		var i GetSpendByKeyRow
		if err := rows.Scan(&i.ApiKey, &i.TotalSpend, &i.TotalTokens); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpendByModel = `-- name: GetSpendByModel :many
SELECT model, SUM(spend) as total_spend, SUM(total_tokens) as total_tokens
FROM "SpendLogs"
WHERE starttime >= $1
GROUP BY model
ORDER BY total_spend DESC
`

type GetSpendByModelRow struct {
	Model       string `json:"model"`
	TotalSpend  int64  `json:"total_spend"`
	TotalTokens int64  `json:"total_tokens"`
}

func (q *Queries) GetSpendByModel(ctx context.Context, starttime pgtype.Timestamptz) ([]GetSpendByModelRow, error) {
	rows, err := q.db.Query(ctx, getSpendByModel, starttime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSpendByModelRow
	for rows.Next() {
		var i GetSpendByModelRow
		if err := rows.Scan(&i.Model, &i.TotalSpend, &i.TotalTokens); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpendByTag = `-- name: GetSpendByTag :many
SELECT unnest(request_tags) as tag, SUM(spend) as total_spend, COUNT(*) as request_count
FROM "SpendLogs"
WHERE starttime >= $1
GROUP BY tag
ORDER BY total_spend DESC
`

type GetSpendByTagRow struct {
	Tag          interface{} `json:"tag"`
	TotalSpend   int64       `json:"total_spend"`
	RequestCount int64       `json:"request_count"`
}

func (q *Queries) GetSpendByTag(ctx context.Context, starttime pgtype.Timestamptz) ([]GetSpendByTagRow, error) {
	rows, err := q.db.Query(ctx, getSpendByTag, starttime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSpendByTagRow
	for rows.Next() {
		var i GetSpendByTagRow
		if err := rows.Scan(&i.Tag, &i.TotalSpend, &i.RequestCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpendByTeam = `-- name: GetSpendByTeam :many
SELECT team_id, SUM(spend) as total_spend, SUM(total_tokens) as total_tokens
FROM "SpendLogs"
WHERE team_id IS NOT NULL AND starttime >= $1
GROUP BY team_id
ORDER BY total_spend DESC
`

type GetSpendByTeamRow struct {
	TeamID      *string `json:"team_id"`
	TotalSpend  int64   `json:"total_spend"`
	TotalTokens int64   `json:"total_tokens"`
}

func (q *Queries) GetSpendByTeam(ctx context.Context, starttime pgtype.Timestamptz) ([]GetSpendByTeamRow, error) {
	rows, err := q.db.Query(ctx, getSpendByTeam, starttime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSpendByTeamRow
	for rows.Next() {
		var i GetSpendByTeamRow
		if err := rows.Scan(&i.TeamID, &i.TotalSpend, &i.TotalTokens); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpendByUser = `-- name: GetSpendByUser :many
SELECT "user", SUM(spend) as total_spend, SUM(total_tokens) as total_tokens
FROM "SpendLogs"
WHERE "user" = ANY($1::text[])
AND starttime >= $2
GROUP BY "user"
`

type GetSpendByUserParams struct {
	Column1   []string           `json:"column_1"`
	Starttime pgtype.Timestamptz `json:"starttime"`
}

type GetSpendByUserRow struct {
	User        string `json:"user"`
	TotalSpend  int64  `json:"total_spend"`
	TotalTokens int64  `json:"total_tokens"`
}

func (q *Queries) GetSpendByUser(ctx context.Context, arg GetSpendByUserParams) ([]GetSpendByUserRow, error) {
	rows, err := q.db.Query(ctx, getSpendByUser, arg.Column1, arg.Starttime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSpendByUserRow
	for rows.Next() {
		var i GetSpendByUserRow
		if err := rows.Scan(&i.User, &i.TotalSpend, &i.TotalTokens); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
