// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: spend_views.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countRequestLogs = `-- name: CountRequestLogs :one
SELECT COUNT(*)
FROM "SpendLogs" sl
LEFT JOIN "ErrorLogs" el ON sl.request_id = el.request_id
WHERE sl.starttime >= $1
  AND sl.starttime < $2
  AND ($3::text IS NULL OR sl.api_key = $3)
  AND ($4::text IS NULL OR sl.team_id = $4)
  AND ($5::text IS NULL OR sl.model = $5)
  AND ($6::text IS NULL OR sl.request_id = $6)
  AND ($7::text IS NULL
       OR ($7 = 'success' AND el.id IS NULL)
       OR ($7 = 'failed' AND el.id IS NOT NULL))
`

type CountRequestLogsParams struct {
	StartDate       pgtype.Timestamptz `json:"start_date"`
	EndDate         pgtype.Timestamptz `json:"end_date"`
	FilterApiKey    *string            `json:"filter_api_key"`
	FilterTeamID    *string            `json:"filter_team_id"`
	FilterModel     *string            `json:"filter_model"`
	FilterRequestID *string            `json:"filter_request_id"`
	FilterStatus    *string            `json:"filter_status"`
}

func (q *Queries) CountRequestLogs(ctx context.Context, arg CountRequestLogsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countRequestLogs,
		arg.StartDate,
		arg.EndDate,
		arg.FilterApiKey,
		arg.FilterTeamID,
		arg.FilterModel,
		arg.FilterRequestID,
		arg.FilterStatus,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSpendLogsByDateRange = `-- name: CountSpendLogsByDateRange :one
SELECT COUNT(*) FROM "SpendLogs"
WHERE starttime >= $1 AND starttime < $2
`

type CountSpendLogsByDateRangeParams struct {
	Starttime   pgtype.Timestamptz `json:"starttime"`
	Starttime_2 pgtype.Timestamptz `json:"starttime_2"`
}

func (q *Queries) CountSpendLogsByDateRange(ctx context.Context, arg CountSpendLogsByDateRangeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSpendLogsByDateRange, arg.Starttime, arg.Starttime_2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createIPWhitelist = `-- name: CreateIPWhitelist :one
INSERT INTO "IPWhitelistTable" (ip_address, description, created_by)
VALUES ($1, $2, $3)
RETURNING id, ip_address, description, created_by, created_at
`

type CreateIPWhitelistParams struct {
	IpAddress   string  `json:"ip_address"`
	Description *string `json:"description"`
	CreatedBy   string  `json:"created_by"`
}

func (q *Queries) CreateIPWhitelist(ctx context.Context, arg CreateIPWhitelistParams) (IPWhitelistTable, error) {
	row := q.db.QueryRow(ctx, createIPWhitelist, arg.IpAddress, arg.Description, arg.CreatedBy)
	var i IPWhitelistTable
	err := row.Scan(
		&i.ID,
		&i.IpAddress,
		&i.Description,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const createSpendArchive = `-- name: CreateSpendArchive :one
INSERT INTO "SpendArchiveTable" (date_from, date_to, storage_type, storage_location, entry_count)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, date_from, date_to, storage_type, storage_location, entry_count, exported_at
`

type CreateSpendArchiveParams struct {
	DateFrom        pgtype.Date `json:"date_from"`
	DateTo          pgtype.Date `json:"date_to"`
	StorageType     string      `json:"storage_type"`
	StorageLocation string      `json:"storage_location"`
	EntryCount      int64       `json:"entry_count"`
}

func (q *Queries) CreateSpendArchive(ctx context.Context, arg CreateSpendArchiveParams) (SpendArchiveTable, error) {
	row := q.db.QueryRow(ctx, createSpendArchive,
		arg.DateFrom,
		arg.DateTo,
		arg.StorageType,
		arg.StorageLocation,
		arg.EntryCount,
	)
	var i SpendArchiveTable
	err := row.Scan(
		&i.ID,
		&i.DateFrom,
		&i.DateTo,
		&i.StorageType,
		&i.StorageLocation,
		&i.EntryCount,
		&i.ExportedAt,
	)
	return i, err
}

const deleteIPWhitelist = `-- name: DeleteIPWhitelist :exec
DELETE FROM "IPWhitelistTable" WHERE id = $1
`

func (q *Queries) DeleteIPWhitelist(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteIPWhitelist, id)
	return err
}

const deleteIPWhitelistByAddress = `-- name: DeleteIPWhitelistByAddress :exec
DELETE FROM "IPWhitelistTable" WHERE ip_address = $1
`

func (q *Queries) DeleteIPWhitelistByAddress(ctx context.Context, ipAddress string) error {
	_, err := q.db.Exec(ctx, deleteIPWhitelistByAddress, ipAddress)
	return err
}

const deleteSpendLogsByDateRange = `-- name: DeleteSpendLogsByDateRange :exec
DELETE FROM "SpendLogs"
WHERE starttime >= $1 AND starttime < $2
`

type DeleteSpendLogsByDateRangeParams struct {
	Starttime   pgtype.Timestamptz `json:"starttime"`
	Starttime_2 pgtype.Timestamptz `json:"starttime_2"`
}

func (q *Queries) DeleteSpendLogsByDateRange(ctx context.Context, arg DeleteSpendLogsByDateRangeParams) error {
	_, err := q.db.Exec(ctx, deleteSpendLogsByDateRange, arg.Starttime, arg.Starttime_2)
	return err
}

const getDailyActivityByKey = `-- name: GetDailyActivityByKey :many
SELECT
    DATE(sl.starttime) AS day,
    sl.api_key,
    COUNT(*) AS request_count,
    COALESCE(SUM(sl.spend), 0)::DOUBLE PRECISION AS total_spend,
    COALESCE(SUM(sl.total_tokens), 0)::BIGINT AS total_tokens
FROM "SpendLogs" sl
WHERE sl.starttime >= $1 AND sl.starttime < $2
  AND sl.api_key IN (
      SELECT s2.api_key FROM "SpendLogs" s2
      WHERE s2.starttime >= $1 AND s2.starttime < $2
      GROUP BY s2.api_key ORDER BY SUM(s2.spend) DESC
      LIMIT $3
  )
GROUP BY DATE(sl.starttime), sl.api_key
ORDER BY day DESC, total_spend DESC
`

type GetDailyActivityByKeyParams struct {
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
	KeyLimit  int32              `json:"key_limit"`
}

type GetDailyActivityByKeyRow struct {
	Day          pgtype.Date `json:"day"`
	ApiKey       string      `json:"api_key"`
	RequestCount int64       `json:"request_count"`
	TotalSpend   float64     `json:"total_spend"`
	TotalTokens  int64       `json:"total_tokens"`
}

func (q *Queries) GetDailyActivityByKey(ctx context.Context, arg GetDailyActivityByKeyParams) ([]GetDailyActivityByKeyRow, error) {
	rows, err := q.db.Query(ctx, getDailyActivityByKey, arg.StartDate, arg.EndDate, arg.KeyLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDailyActivityByKeyRow
	for rows.Next() {
		var i GetDailyActivityByKeyRow
		if err := rows.Scan(
			&i.Day,
			&i.ApiKey,
			&i.RequestCount,
			&i.TotalSpend,
			&i.TotalTokens,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDailySpendByCallType = `-- name: GetDailySpendByCallType :many
SELECT
    DATE(starttime) AS day,
    call_type,
    COUNT(*) AS request_count,
    SUM(total_tokens)::BIGINT AS total_tokens
FROM "SpendLogs"
WHERE starttime >= $1 AND starttime < $2
GROUP BY DATE(starttime), call_type
ORDER BY day DESC, request_count DESC
`

type GetDailySpendByCallTypeParams struct {
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
}

type GetDailySpendByCallTypeRow struct {
	Day          pgtype.Date `json:"day"`
	CallType     string      `json:"call_type"`
	RequestCount int64       `json:"request_count"`
	TotalTokens  int64       `json:"total_tokens"`
}

func (q *Queries) GetDailySpendByCallType(ctx context.Context, arg GetDailySpendByCallTypeParams) ([]GetDailySpendByCallTypeRow, error) {
	rows, err := q.db.Query(ctx, getDailySpendByCallType, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDailySpendByCallTypeRow
	for rows.Next() {
		var i GetDailySpendByCallTypeRow
		if err := rows.Scan(
			&i.Day,
			&i.CallType,
			&i.RequestCount,
			&i.TotalTokens,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDailySpendByKey = `-- name: GetDailySpendByKey :many
SELECT DATE(starttime) AS day, api_key, COALESCE(SUM(spend), 0)::DOUBLE PRECISION AS total_spend,
       COALESCE(SUM(total_tokens), 0)::BIGINT AS total_tokens, COUNT(*) AS request_count
FROM "SpendLogs"
WHERE starttime >= $1 AND starttime < $2
GROUP BY DATE(starttime), api_key
ORDER BY day DESC, total_spend DESC
`

type GetDailySpendByKeyParams struct {
	Starttime   pgtype.Timestamptz `json:"starttime"`
	Starttime_2 pgtype.Timestamptz `json:"starttime_2"`
}

type GetDailySpendByKeyRow struct {
	Day          pgtype.Date `json:"day"`
	ApiKey       string      `json:"api_key"`
	TotalSpend   float64     `json:"total_spend"`
	TotalTokens  int64       `json:"total_tokens"`
	RequestCount int64       `json:"request_count"`
}

func (q *Queries) GetDailySpendByKey(ctx context.Context, arg GetDailySpendByKeyParams) ([]GetDailySpendByKeyRow, error) {
	rows, err := q.db.Query(ctx, getDailySpendByKey, arg.Starttime, arg.Starttime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDailySpendByKeyRow
	for rows.Next() {
		var i GetDailySpendByKeyRow
		if err := rows.Scan(
			&i.Day,
			&i.ApiKey,
			&i.TotalSpend,
			&i.TotalTokens,
			&i.RequestCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDailySpendByModel = `-- name: GetDailySpendByModel :many
SELECT DATE(starttime) AS day, model, COALESCE(SUM(spend), 0)::DOUBLE PRECISION AS total_spend,
       COALESCE(SUM(total_tokens), 0)::BIGINT AS total_tokens, COUNT(*) AS request_count
FROM "SpendLogs"
WHERE starttime >= $1 AND starttime < $2
GROUP BY DATE(starttime), model
ORDER BY day DESC, total_spend DESC
`

type GetDailySpendByModelParams struct {
	Starttime   pgtype.Timestamptz `json:"starttime"`
	Starttime_2 pgtype.Timestamptz `json:"starttime_2"`
}

type GetDailySpendByModelRow struct {
	Day          pgtype.Date `json:"day"`
	Model        string      `json:"model"`
	TotalSpend   float64     `json:"total_spend"`
	TotalTokens  int64       `json:"total_tokens"`
	RequestCount int64       `json:"request_count"`
}

func (q *Queries) GetDailySpendByModel(ctx context.Context, arg GetDailySpendByModelParams) ([]GetDailySpendByModelRow, error) {
	rows, err := q.db.Query(ctx, getDailySpendByModel, arg.Starttime, arg.Starttime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDailySpendByModelRow
	for rows.Next() {
		var i GetDailySpendByModelRow
		if err := rows.Scan(
			&i.Day,
			&i.Model,
			&i.TotalSpend,
			&i.TotalTokens,
			&i.RequestCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDailySpendByTag = `-- name: GetDailySpendByTag :many
SELECT DATE(starttime) AS day, tag, COALESCE(SUM(spend), 0)::DOUBLE PRECISION AS total_spend, COUNT(*) AS request_count
FROM "SpendLogs", unnest(request_tags) AS tag
WHERE starttime >= $1 AND starttime < $2
GROUP BY DATE(starttime), tag
ORDER BY day DESC, total_spend DESC
`

type GetDailySpendByTagParams struct {
	Starttime   pgtype.Timestamptz `json:"starttime"`
	Starttime_2 pgtype.Timestamptz `json:"starttime_2"`
}

type GetDailySpendByTagRow struct {
	Day          pgtype.Date `json:"day"`
	Tag          interface{} `json:"tag"`
	TotalSpend   float64     `json:"total_spend"`
	RequestCount int64       `json:"request_count"`
}

func (q *Queries) GetDailySpendByTag(ctx context.Context, arg GetDailySpendByTagParams) ([]GetDailySpendByTagRow, error) {
	rows, err := q.db.Query(ctx, getDailySpendByTag, arg.Starttime, arg.Starttime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDailySpendByTagRow
	for rows.Next() {
		var i GetDailySpendByTagRow
		if err := rows.Scan(
			&i.Day,
			&i.Tag,
			&i.TotalSpend,
			&i.RequestCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDailySpendByTeam = `-- name: GetDailySpendByTeam :many

SELECT DATE(starttime) AS day, team_id, COALESCE(SUM(spend), 0)::DOUBLE PRECISION AS total_spend,
       COALESCE(SUM(total_tokens), 0)::BIGINT AS total_tokens, COUNT(*) AS request_count
FROM "SpendLogs"
WHERE starttime >= $1 AND starttime < $2
GROUP BY DATE(starttime), team_id
ORDER BY day DESC, total_spend DESC
`

type GetDailySpendByTeamParams struct {
	Starttime   pgtype.Timestamptz `json:"starttime"`
	Starttime_2 pgtype.Timestamptz `json:"starttime_2"`
}

type GetDailySpendByTeamRow struct {
	Day          pgtype.Date `json:"day"`
	TeamID       *string     `json:"team_id"`
	TotalSpend   float64     `json:"total_spend"`
	TotalTokens  int64       `json:"total_tokens"`
	RequestCount int64       `json:"request_count"`
}

// Spend aggregation queries
func (q *Queries) GetDailySpendByTeam(ctx context.Context, arg GetDailySpendByTeamParams) ([]GetDailySpendByTeamRow, error) {
	rows, err := q.db.Query(ctx, getDailySpendByTeam, arg.Starttime, arg.Starttime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDailySpendByTeamRow
	for rows.Next() {
		var i GetDailySpendByTeamRow
		if err := rows.Scan(
			&i.Day,
			&i.TeamID,
			&i.TotalSpend,
			&i.TotalTokens,
			&i.RequestCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFailedRequestCount = `-- name: GetFailedRequestCount :one
SELECT COUNT(DISTINCT el.request_id) AS failed_requests
FROM "ErrorLogs" el
WHERE el.request_id IN (
    SELECT request_id FROM "SpendLogs"
    WHERE starttime >= $1 AND starttime < $2
)
`

type GetFailedRequestCountParams struct {
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
}

func (q *Queries) GetFailedRequestCount(ctx context.Context, arg GetFailedRequestCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getFailedRequestCount, arg.StartDate, arg.EndDate)
	var failed_requests int64
	err := row.Scan(&failed_requests)
	return failed_requests, err
}

const getGlobalSpend = `-- name: GetGlobalSpend :one
SELECT COALESCE(SUM(spend), 0)::DOUBLE PRECISION AS total_spend,
       COALESCE(SUM(total_tokens), 0)::BIGINT AS total_tokens,
       COUNT(*) AS request_count
FROM "SpendLogs"
WHERE starttime >= $1 AND starttime < $2
`

type GetGlobalSpendParams struct {
	Starttime   pgtype.Timestamptz `json:"starttime"`
	Starttime_2 pgtype.Timestamptz `json:"starttime_2"`
}

type GetGlobalSpendRow struct {
	TotalSpend   float64 `json:"total_spend"`
	TotalTokens  int64   `json:"total_tokens"`
	RequestCount int64   `json:"request_count"`
}

func (q *Queries) GetGlobalSpend(ctx context.Context, arg GetGlobalSpendParams) (GetGlobalSpendRow, error) {
	row := q.db.QueryRow(ctx, getGlobalSpend, arg.Starttime, arg.Starttime_2)
	var i GetGlobalSpendRow
	err := row.Scan(&i.TotalSpend, &i.TotalTokens, &i.RequestCount)
	return i, err
}

const getGlobalSpendByProvider = `-- name: GetGlobalSpendByProvider :many
SELECT SPLIT_PART(model, '/', 1) AS provider, COALESCE(SUM(spend), 0)::DOUBLE PRECISION AS total_spend,
       COUNT(*) AS request_count
FROM "SpendLogs"
WHERE starttime >= $1 AND starttime < $2
GROUP BY provider
ORDER BY total_spend DESC
`

type GetGlobalSpendByProviderParams struct {
	Starttime   pgtype.Timestamptz `json:"starttime"`
	Starttime_2 pgtype.Timestamptz `json:"starttime_2"`
}

type GetGlobalSpendByProviderRow struct {
	Provider     string  `json:"provider"`
	TotalSpend   float64 `json:"total_spend"`
	RequestCount int64   `json:"request_count"`
}

func (q *Queries) GetGlobalSpendByProvider(ctx context.Context, arg GetGlobalSpendByProviderParams) ([]GetGlobalSpendByProviderRow, error) {
	rows, err := q.db.Query(ctx, getGlobalSpendByProvider, arg.Starttime, arg.Starttime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGlobalSpendByProviderRow
	for rows.Next() {
		var i GetGlobalSpendByProviderRow
		if err := rows.Scan(&i.Provider, &i.TotalSpend, &i.RequestCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIPWhitelist = `-- name: GetIPWhitelist :one
SELECT id, ip_address, description, created_by, created_at FROM "IPWhitelistTable" WHERE id = $1
`

func (q *Queries) GetIPWhitelist(ctx context.Context, id string) (IPWhitelistTable, error) {
	row := q.db.QueryRow(ctx, getIPWhitelist, id)
	var i IPWhitelistTable
	err := row.Scan(
		&i.ID,
		&i.IpAddress,
		&i.Description,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getSpendArchive = `-- name: GetSpendArchive :one
SELECT id, date_from, date_to, storage_type, storage_location, entry_count, exported_at FROM "SpendArchiveTable" WHERE id = $1
`

func (q *Queries) GetSpendArchive(ctx context.Context, id string) (SpendArchiveTable, error) {
	row := q.db.QueryRow(ctx, getSpendArchive, id)
	var i SpendArchiveTable
	err := row.Scan(
		&i.ID,
		&i.DateFrom,
		&i.DateTo,
		&i.StorageType,
		&i.StorageLocation,
		&i.EntryCount,
		&i.ExportedAt,
	)
	return i, err
}

const getSpendArchiveByDateRange = `-- name: GetSpendArchiveByDateRange :many
SELECT id, date_from, date_to, storage_type, storage_location, entry_count, exported_at FROM "SpendArchiveTable"
WHERE date_from <= $2 AND date_to >= $1
ORDER BY date_from
`

type GetSpendArchiveByDateRangeParams struct {
	DateTo   pgtype.Date `json:"date_to"`
	DateFrom pgtype.Date `json:"date_from"`
}

func (q *Queries) GetSpendArchiveByDateRange(ctx context.Context, arg GetSpendArchiveByDateRangeParams) ([]SpendArchiveTable, error) {
	rows, err := q.db.Query(ctx, getSpendArchiveByDateRange, arg.DateTo, arg.DateFrom)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SpendArchiveTable
	for rows.Next() {
		var i SpendArchiveTable
		if err := rows.Scan(
			&i.ID,
			&i.DateFrom,
			&i.DateTo,
			&i.StorageType,
			&i.StorageLocation,
			&i.EntryCount,
			&i.ExportedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpendLogsByFilter = `-- name: GetSpendLogsByFilter :many
SELECT request_id, starttime, api_key, model, spend, total_tokens, team_id, "user"
FROM "SpendLogs"
WHERE starttime >= $1 AND starttime < $2
  AND ($3::text IS NULL OR api_key = $3)
  AND ($4::text IS NULL OR team_id = $4)
  AND ($5::text IS NULL OR model = $5)
ORDER BY starttime DESC
LIMIT $6 OFFSET $7
`

type GetSpendLogsByFilterParams struct {
	Starttime   pgtype.Timestamptz `json:"starttime"`
	Starttime_2 pgtype.Timestamptz `json:"starttime_2"`
	Column3     string             `json:"column_3"`
	Column4     string             `json:"column_4"`
	Column5     string             `json:"column_5"`
	Limit       int32              `json:"limit"`
	Offset      int32              `json:"offset"`
}

type GetSpendLogsByFilterRow struct {
	RequestID   string             `json:"request_id"`
	Starttime   pgtype.Timestamptz `json:"starttime"`
	ApiKey      string             `json:"api_key"`
	Model       string             `json:"model"`
	Spend       float64            `json:"spend"`
	TotalTokens int32              `json:"total_tokens"`
	TeamID      *string            `json:"team_id"`
	User        string             `json:"user"`
}

func (q *Queries) GetSpendLogsByFilter(ctx context.Context, arg GetSpendLogsByFilterParams) ([]GetSpendLogsByFilterRow, error) {
	rows, err := q.db.Query(ctx, getSpendLogsByFilter,
		arg.Starttime,
		arg.Starttime_2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSpendLogsByFilterRow
	for rows.Next() {
		var i GetSpendLogsByFilterRow
		if err := rows.Scan(
			&i.RequestID,
			&i.Starttime,
			&i.ApiKey,
			&i.Model,
			&i.Spend,
			&i.TotalTokens,
			&i.TeamID,
			&i.User,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpendLogsForArchival = `-- name: GetSpendLogsForArchival :many
SELECT request_id, call_type, api_key, spend, total_tokens, prompt_tokens, completion_tokens, starttime, endtime, completionstartime, model, model_id, model_group, api_base, "user", metadata, cache_hit, cache_key, request_tags, team_id, end_user, requester_ip_address, organization_id, provider
FROM "SpendLogs"
WHERE starttime >= $1 AND starttime < $2
ORDER BY starttime
LIMIT $3
`

type GetSpendLogsForArchivalParams struct {
	Starttime   pgtype.Timestamptz `json:"starttime"`
	Starttime_2 pgtype.Timestamptz `json:"starttime_2"`
	Limit       int32              `json:"limit"`
}

func (q *Queries) GetSpendLogsForArchival(ctx context.Context, arg GetSpendLogsForArchivalParams) ([]SpendLog, error) {
	rows, err := q.db.Query(ctx, getSpendLogsForArchival, arg.Starttime, arg.Starttime_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SpendLog
	for rows.Next() {
		var i SpendLog
		if err := rows.Scan(
			&i.RequestID,
			&i.CallType,
			&i.ApiKey,
			&i.Spend,
			&i.TotalTokens,
			&i.PromptTokens,
			&i.CompletionTokens,
			&i.Starttime,
			&i.Endtime,
			&i.Completionstartime,
			&i.Model,
			&i.ModelID,
			&i.ModelGroup,
			&i.ApiBase,
			&i.User,
			&i.Metadata,
			&i.CacheHit,
			&i.CacheKey,
			&i.RequestTags,
			&i.TeamID,
			&i.EndUser,
			&i.RequesterIpAddress,
			&i.OrganizationID,
			&i.Provider,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamDailyActivity = `-- name: GetTeamDailyActivity :many
SELECT DATE(starttime) AS day, model, COALESCE(SUM(spend), 0)::DOUBLE PRECISION AS total_spend,
       COALESCE(SUM(total_tokens), 0)::BIGINT AS total_tokens, COUNT(*) AS request_count
FROM "SpendLogs"
WHERE team_id = $1 AND starttime >= $2 AND starttime < $3
GROUP BY DATE(starttime), model
ORDER BY day DESC, total_spend DESC
`

type GetTeamDailyActivityParams struct {
	TeamID      *string            `json:"team_id"`
	Starttime   pgtype.Timestamptz `json:"starttime"`
	Starttime_2 pgtype.Timestamptz `json:"starttime_2"`
}

type GetTeamDailyActivityRow struct {
	Day          pgtype.Date `json:"day"`
	Model        string      `json:"model"`
	TotalSpend   float64     `json:"total_spend"`
	TotalTokens  int64       `json:"total_tokens"`
	RequestCount int64       `json:"request_count"`
}

func (q *Queries) GetTeamDailyActivity(ctx context.Context, arg GetTeamDailyActivityParams) ([]GetTeamDailyActivityRow, error) {
	rows, err := q.db.Query(ctx, getTeamDailyActivity, arg.TeamID, arg.Starttime, arg.Starttime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamDailyActivityRow
	for rows.Next() {
		var i GetTeamDailyActivityRow
		if err := rows.Scan(
			&i.Day,
			&i.Model,
			&i.TotalSpend,
			&i.TotalTokens,
			&i.RequestCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopKeysBySpend = `-- name: GetTopKeysBySpend :many
SELECT
    sl.api_key,
    COALESCE(vt.key_alias, '') AS key_alias,
    COALESCE(SUM(sl.spend), 0)::DOUBLE PRECISION AS total_spend,
    COUNT(*) AS request_count
FROM "SpendLogs" sl
LEFT JOIN "VerificationToken" vt ON sl.api_key = vt.token
WHERE sl.starttime >= $1 AND sl.starttime < $2
GROUP BY sl.api_key, vt.key_alias
ORDER BY total_spend DESC
LIMIT $3
`

type GetTopKeysBySpendParams struct {
	StartDate  pgtype.Timestamptz `json:"start_date"`
	EndDate    pgtype.Timestamptz `json:"end_date"`
	QueryLimit int32              `json:"query_limit"`
}

type GetTopKeysBySpendRow struct {
	ApiKey       string  `json:"api_key"`
	KeyAlias     string  `json:"key_alias"`
	TotalSpend   float64 `json:"total_spend"`
	RequestCount int64   `json:"request_count"`
}

func (q *Queries) GetTopKeysBySpend(ctx context.Context, arg GetTopKeysBySpendParams) ([]GetTopKeysBySpendRow, error) {
	rows, err := q.db.Query(ctx, getTopKeysBySpend, arg.StartDate, arg.EndDate, arg.QueryLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopKeysBySpendRow
	for rows.Next() {
		var i GetTopKeysBySpendRow
		if err := rows.Scan(
			&i.ApiKey,
			&i.KeyAlias,
			&i.TotalSpend,
			&i.RequestCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopModelsBySpend = `-- name: GetTopModelsBySpend :many
SELECT
    model,
    COALESCE(SUM(spend), 0)::DOUBLE PRECISION AS total_spend,
    COALESCE(SUM(total_tokens), 0)::BIGINT AS total_tokens,
    COUNT(*) AS request_count
FROM "SpendLogs"
WHERE starttime >= $1 AND starttime < $2
GROUP BY model
ORDER BY total_spend DESC
LIMIT $3
`

type GetTopModelsBySpendParams struct {
	StartDate  pgtype.Timestamptz `json:"start_date"`
	EndDate    pgtype.Timestamptz `json:"end_date"`
	QueryLimit int32              `json:"query_limit"`
}

type GetTopModelsBySpendRow struct {
	Model        string  `json:"model"`
	TotalSpend   float64 `json:"total_spend"`
	TotalTokens  int64   `json:"total_tokens"`
	RequestCount int64   `json:"request_count"`
}

func (q *Queries) GetTopModelsBySpend(ctx context.Context, arg GetTopModelsBySpendParams) ([]GetTopModelsBySpendRow, error) {
	rows, err := q.db.Query(ctx, getTopModelsBySpend, arg.StartDate, arg.EndDate, arg.QueryLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopModelsBySpendRow
	for rows.Next() {
		var i GetTopModelsBySpendRow
		if err := rows.Scan(
			&i.Model,
			&i.TotalSpend,
			&i.TotalTokens,
			&i.RequestCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsageMetrics = `-- name: GetUsageMetrics :one

SELECT
    COUNT(*) AS total_requests,
    COALESCE(SUM(total_tokens), 0)::BIGINT AS total_tokens,
    COALESCE(SUM(spend), 0)::DOUBLE PRECISION AS total_spend
FROM "SpendLogs"
WHERE starttime >= $1 AND starttime < $2
`

type GetUsageMetricsParams struct {
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
}

type GetUsageMetricsRow struct {
	TotalRequests int64   `json:"total_requests"`
	TotalTokens   int64   `json:"total_tokens"`
	TotalSpend    float64 `json:"total_spend"`
}

// Usage Dashboard queries
func (q *Queries) GetUsageMetrics(ctx context.Context, arg GetUsageMetricsParams) (GetUsageMetricsRow, error) {
	row := q.db.QueryRow(ctx, getUsageMetrics, arg.StartDate, arg.EndDate)
	var i GetUsageMetricsRow
	err := row.Scan(&i.TotalRequests, &i.TotalTokens, &i.TotalSpend)
	return i, err
}

const getUserDailyActivity = `-- name: GetUserDailyActivity :many
SELECT DATE(starttime) AS day, model, COALESCE(SUM(spend), 0)::DOUBLE PRECISION AS total_spend,
       COALESCE(SUM(total_tokens), 0)::BIGINT AS total_tokens, COUNT(*) AS request_count
FROM "SpendLogs"
WHERE "user" = $1 AND starttime >= $2 AND starttime < $3
GROUP BY DATE(starttime), model
ORDER BY day DESC, total_spend DESC
`

type GetUserDailyActivityParams struct {
	User        string             `json:"user"`
	Starttime   pgtype.Timestamptz `json:"starttime"`
	Starttime_2 pgtype.Timestamptz `json:"starttime_2"`
}

type GetUserDailyActivityRow struct {
	Day          pgtype.Date `json:"day"`
	Model        string      `json:"model"`
	TotalSpend   float64     `json:"total_spend"`
	TotalTokens  int64       `json:"total_tokens"`
	RequestCount int64       `json:"request_count"`
}

func (q *Queries) GetUserDailyActivity(ctx context.Context, arg GetUserDailyActivityParams) ([]GetUserDailyActivityRow, error) {
	rows, err := q.db.Query(ctx, getUserDailyActivity, arg.User, arg.Starttime, arg.Starttime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserDailyActivityRow
	for rows.Next() {
		var i GetUserDailyActivityRow
		if err := rows.Scan(
			&i.Day,
			&i.Model,
			&i.TotalSpend,
			&i.TotalTokens,
			&i.RequestCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIPWhitelist = `-- name: ListIPWhitelist :many
SELECT id, ip_address, description, created_by, created_at FROM "IPWhitelistTable" ORDER BY created_at DESC
`

func (q *Queries) ListIPWhitelist(ctx context.Context) ([]IPWhitelistTable, error) {
	rows, err := q.db.Query(ctx, listIPWhitelist)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []IPWhitelistTable
	for rows.Next() {
		var i IPWhitelistTable
		if err := rows.Scan(
			&i.ID,
			&i.IpAddress,
			&i.Description,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRequestLogs = `-- name: ListRequestLogs :many

SELECT
    sl.request_id,
    sl.starttime,
    sl.endtime,
    sl.api_key,
    sl.model,
    sl.spend,
    sl.total_tokens,
    sl.prompt_tokens,
    sl.completion_tokens,
    sl.call_type,
    sl.cache_hit,
    sl.team_id,
    sl."user",
    sl.end_user,
    sl.requester_ip_address,
    el.status_code AS error_status_code,
    el.error_type
FROM "SpendLogs" sl
LEFT JOIN "ErrorLogs" el ON sl.request_id = el.request_id
WHERE sl.starttime >= $1
  AND sl.starttime < $2
  AND ($3::text IS NULL OR sl.api_key = $3)
  AND ($4::text IS NULL OR sl.team_id = $4)
  AND ($5::text IS NULL OR sl.model = $5)
  AND ($6::text IS NULL OR sl.request_id = $6)
  AND ($7::text IS NULL
       OR ($7 = 'success' AND el.id IS NULL)
       OR ($7 = 'failed' AND el.id IS NOT NULL))
ORDER BY sl.starttime DESC
LIMIT $9 OFFSET $8
`

type ListRequestLogsParams struct {
	StartDate       pgtype.Timestamptz `json:"start_date"`
	EndDate         pgtype.Timestamptz `json:"end_date"`
	FilterApiKey    *string            `json:"filter_api_key"`
	FilterTeamID    *string            `json:"filter_team_id"`
	FilterModel     *string            `json:"filter_model"`
	FilterRequestID *string            `json:"filter_request_id"`
	FilterStatus    *string            `json:"filter_status"`
	QueryOffset     int32              `json:"query_offset"`
	QueryLimit      int32              `json:"query_limit"`
}

type ListRequestLogsRow struct {
	RequestID          string             `json:"request_id"`
	Starttime          pgtype.Timestamptz `json:"starttime"`
	Endtime            pgtype.Timestamptz `json:"endtime"`
	ApiKey             string             `json:"api_key"`
	Model              string             `json:"model"`
	Spend              float64            `json:"spend"`
	TotalTokens        int32              `json:"total_tokens"`
	PromptTokens       int32              `json:"prompt_tokens"`
	CompletionTokens   int32              `json:"completion_tokens"`
	CallType           string             `json:"call_type"`
	CacheHit           string             `json:"cache_hit"`
	TeamID             *string            `json:"team_id"`
	User               string             `json:"user"`
	EndUser            *string            `json:"end_user"`
	RequesterIpAddress *string            `json:"requester_ip_address"`
	ErrorStatusCode    *int32             `json:"error_status_code"`
	ErrorType          *string            `json:"error_type"`
}

// Request Logs Dashboard queries
func (q *Queries) ListRequestLogs(ctx context.Context, arg ListRequestLogsParams) ([]ListRequestLogsRow, error) {
	rows, err := q.db.Query(ctx, listRequestLogs,
		arg.StartDate,
		arg.EndDate,
		arg.FilterApiKey,
		arg.FilterTeamID,
		arg.FilterModel,
		arg.FilterRequestID,
		arg.FilterStatus,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRequestLogsRow
	for rows.Next() {
		var i ListRequestLogsRow
		if err := rows.Scan(
			&i.RequestID,
			&i.Starttime,
			&i.Endtime,
			&i.ApiKey,
			&i.Model,
			&i.Spend,
			&i.TotalTokens,
			&i.PromptTokens,
			&i.CompletionTokens,
			&i.CallType,
			&i.CacheHit,
			&i.TeamID,
			&i.User,
			&i.EndUser,
			&i.RequesterIpAddress,
			&i.ErrorStatusCode,
			&i.ErrorType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSpendArchives = `-- name: ListSpendArchives :many
SELECT id, date_from, date_to, storage_type, storage_location, entry_count, exported_at FROM "SpendArchiveTable" ORDER BY date_from DESC
`

func (q *Queries) ListSpendArchives(ctx context.Context) ([]SpendArchiveTable, error) {
	rows, err := q.db.Query(ctx, listSpendArchives)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SpendArchiveTable
	for rows.Next() {
		var i SpendArchiveTable
		if err := rows.Scan(
			&i.ID,
			&i.DateFrom,
			&i.DateTo,
			&i.StorageType,
			&i.StorageLocation,
			&i.EntryCount,
			&i.ExportedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
