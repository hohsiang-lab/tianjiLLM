// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: spend_views.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countSpendLogsByDateRange = `-- name: CountSpendLogsByDateRange :one
SELECT COUNT(*) FROM "SpendLogs"
WHERE starttime >= $1 AND starttime < $2
`

type CountSpendLogsByDateRangeParams struct {
	Starttime   pgtype.Timestamptz `json:"starttime"`
	Starttime_2 pgtype.Timestamptz `json:"starttime_2"`
}

func (q *Queries) CountSpendLogsByDateRange(ctx context.Context, arg CountSpendLogsByDateRangeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSpendLogsByDateRange, arg.Starttime, arg.Starttime_2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createIPWhitelist = `-- name: CreateIPWhitelist :one
INSERT INTO "IPWhitelistTable" (ip_address, description, created_by)
VALUES ($1, $2, $3)
RETURNING id, ip_address, description, created_by, created_at
`

type CreateIPWhitelistParams struct {
	IpAddress   string  `json:"ip_address"`
	Description *string `json:"description"`
	CreatedBy   string  `json:"created_by"`
}

func (q *Queries) CreateIPWhitelist(ctx context.Context, arg CreateIPWhitelistParams) (IPWhitelistTable, error) {
	row := q.db.QueryRow(ctx, createIPWhitelist, arg.IpAddress, arg.Description, arg.CreatedBy)
	var i IPWhitelistTable
	err := row.Scan(
		&i.ID,
		&i.IpAddress,
		&i.Description,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const createSpendArchive = `-- name: CreateSpendArchive :one
INSERT INTO "SpendArchiveTable" (date_from, date_to, storage_type, storage_location, entry_count)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, date_from, date_to, storage_type, storage_location, entry_count, exported_at
`

type CreateSpendArchiveParams struct {
	DateFrom        pgtype.Date `json:"date_from"`
	DateTo          pgtype.Date `json:"date_to"`
	StorageType     string      `json:"storage_type"`
	StorageLocation string      `json:"storage_location"`
	EntryCount      int64       `json:"entry_count"`
}

func (q *Queries) CreateSpendArchive(ctx context.Context, arg CreateSpendArchiveParams) (SpendArchiveTable, error) {
	row := q.db.QueryRow(ctx, createSpendArchive,
		arg.DateFrom,
		arg.DateTo,
		arg.StorageType,
		arg.StorageLocation,
		arg.EntryCount,
	)
	var i SpendArchiveTable
	err := row.Scan(
		&i.ID,
		&i.DateFrom,
		&i.DateTo,
		&i.StorageType,
		&i.StorageLocation,
		&i.EntryCount,
		&i.ExportedAt,
	)
	return i, err
}

const deleteIPWhitelist = `-- name: DeleteIPWhitelist :exec
DELETE FROM "IPWhitelistTable" WHERE id = $1
`

func (q *Queries) DeleteIPWhitelist(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteIPWhitelist, id)
	return err
}

const deleteIPWhitelistByAddress = `-- name: DeleteIPWhitelistByAddress :exec
DELETE FROM "IPWhitelistTable" WHERE ip_address = $1
`

func (q *Queries) DeleteIPWhitelistByAddress(ctx context.Context, ipAddress string) error {
	_, err := q.db.Exec(ctx, deleteIPWhitelistByAddress, ipAddress)
	return err
}

const deleteSpendLogsByDateRange = `-- name: DeleteSpendLogsByDateRange :exec
DELETE FROM "SpendLogs"
WHERE starttime >= $1 AND starttime < $2
`

type DeleteSpendLogsByDateRangeParams struct {
	Starttime   pgtype.Timestamptz `json:"starttime"`
	Starttime_2 pgtype.Timestamptz `json:"starttime_2"`
}

func (q *Queries) DeleteSpendLogsByDateRange(ctx context.Context, arg DeleteSpendLogsByDateRangeParams) error {
	_, err := q.db.Exec(ctx, deleteSpendLogsByDateRange, arg.Starttime, arg.Starttime_2)
	return err
}

const getDailySpendByKey = `-- name: GetDailySpendByKey :many
SELECT DATE(starttime) AS day, api_key, SUM(spend) AS total_spend,
       SUM(total_tokens) AS total_tokens, COUNT(*) AS request_count
FROM "SpendLogs"
WHERE starttime >= $1 AND starttime < $2
GROUP BY DATE(starttime), api_key
ORDER BY day DESC, total_spend DESC
`

type GetDailySpendByKeyParams struct {
	Starttime   pgtype.Timestamptz `json:"starttime"`
	Starttime_2 pgtype.Timestamptz `json:"starttime_2"`
}

type GetDailySpendByKeyRow struct {
	Day          pgtype.Date `json:"day"`
	ApiKey       string      `json:"api_key"`
	TotalSpend   int64       `json:"total_spend"`
	TotalTokens  int64       `json:"total_tokens"`
	RequestCount int64       `json:"request_count"`
}

func (q *Queries) GetDailySpendByKey(ctx context.Context, arg GetDailySpendByKeyParams) ([]GetDailySpendByKeyRow, error) {
	rows, err := q.db.Query(ctx, getDailySpendByKey, arg.Starttime, arg.Starttime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDailySpendByKeyRow
	for rows.Next() {
		var i GetDailySpendByKeyRow
		if err := rows.Scan(
			&i.Day,
			&i.ApiKey,
			&i.TotalSpend,
			&i.TotalTokens,
			&i.RequestCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDailySpendByModel = `-- name: GetDailySpendByModel :many
SELECT DATE(starttime) AS day, model, SUM(spend) AS total_spend,
       SUM(total_tokens) AS total_tokens, COUNT(*) AS request_count
FROM "SpendLogs"
WHERE starttime >= $1 AND starttime < $2
GROUP BY DATE(starttime), model
ORDER BY day DESC, total_spend DESC
`

type GetDailySpendByModelParams struct {
	Starttime   pgtype.Timestamptz `json:"starttime"`
	Starttime_2 pgtype.Timestamptz `json:"starttime_2"`
}

type GetDailySpendByModelRow struct {
	Day          pgtype.Date `json:"day"`
	Model        string      `json:"model"`
	TotalSpend   int64       `json:"total_spend"`
	TotalTokens  int64       `json:"total_tokens"`
	RequestCount int64       `json:"request_count"`
}

func (q *Queries) GetDailySpendByModel(ctx context.Context, arg GetDailySpendByModelParams) ([]GetDailySpendByModelRow, error) {
	rows, err := q.db.Query(ctx, getDailySpendByModel, arg.Starttime, arg.Starttime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDailySpendByModelRow
	for rows.Next() {
		var i GetDailySpendByModelRow
		if err := rows.Scan(
			&i.Day,
			&i.Model,
			&i.TotalSpend,
			&i.TotalTokens,
			&i.RequestCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDailySpendByTag = `-- name: GetDailySpendByTag :many
SELECT DATE(starttime) AS day, tag, SUM(spend) AS total_spend, COUNT(*) AS request_count
FROM "SpendLogs", unnest(request_tags) AS tag
WHERE starttime >= $1 AND starttime < $2
GROUP BY DATE(starttime), tag
ORDER BY day DESC, total_spend DESC
`

type GetDailySpendByTagParams struct {
	Starttime   pgtype.Timestamptz `json:"starttime"`
	Starttime_2 pgtype.Timestamptz `json:"starttime_2"`
}

type GetDailySpendByTagRow struct {
	Day          pgtype.Date `json:"day"`
	Tag          interface{} `json:"tag"`
	TotalSpend   int64       `json:"total_spend"`
	RequestCount int64       `json:"request_count"`
}

func (q *Queries) GetDailySpendByTag(ctx context.Context, arg GetDailySpendByTagParams) ([]GetDailySpendByTagRow, error) {
	rows, err := q.db.Query(ctx, getDailySpendByTag, arg.Starttime, arg.Starttime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDailySpendByTagRow
	for rows.Next() {
		var i GetDailySpendByTagRow
		if err := rows.Scan(
			&i.Day,
			&i.Tag,
			&i.TotalSpend,
			&i.RequestCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDailySpendByTeam = `-- name: GetDailySpendByTeam :many

SELECT DATE(starttime) AS day, team_id, SUM(spend) AS total_spend,
       SUM(total_tokens) AS total_tokens, COUNT(*) AS request_count
FROM "SpendLogs"
WHERE starttime >= $1 AND starttime < $2
GROUP BY DATE(starttime), team_id
ORDER BY day DESC, total_spend DESC
`

type GetDailySpendByTeamParams struct {
	Starttime   pgtype.Timestamptz `json:"starttime"`
	Starttime_2 pgtype.Timestamptz `json:"starttime_2"`
}

type GetDailySpendByTeamRow struct {
	Day          pgtype.Date `json:"day"`
	TeamID       *string     `json:"team_id"`
	TotalSpend   int64       `json:"total_spend"`
	TotalTokens  int64       `json:"total_tokens"`
	RequestCount int64       `json:"request_count"`
}

// Spend aggregation queries
func (q *Queries) GetDailySpendByTeam(ctx context.Context, arg GetDailySpendByTeamParams) ([]GetDailySpendByTeamRow, error) {
	rows, err := q.db.Query(ctx, getDailySpendByTeam, arg.Starttime, arg.Starttime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDailySpendByTeamRow
	for rows.Next() {
		var i GetDailySpendByTeamRow
		if err := rows.Scan(
			&i.Day,
			&i.TeamID,
			&i.TotalSpend,
			&i.TotalTokens,
			&i.RequestCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGlobalSpend = `-- name: GetGlobalSpend :one
SELECT COALESCE(SUM(spend), 0) AS total_spend,
       COALESCE(SUM(total_tokens), 0)::BIGINT AS total_tokens,
       COUNT(*) AS request_count
FROM "SpendLogs"
WHERE starttime >= $1 AND starttime < $2
`

type GetGlobalSpendParams struct {
	Starttime   pgtype.Timestamptz `json:"starttime"`
	Starttime_2 pgtype.Timestamptz `json:"starttime_2"`
}

type GetGlobalSpendRow struct {
	TotalSpend   interface{} `json:"total_spend"`
	TotalTokens  int64       `json:"total_tokens"`
	RequestCount int64       `json:"request_count"`
}

func (q *Queries) GetGlobalSpend(ctx context.Context, arg GetGlobalSpendParams) (GetGlobalSpendRow, error) {
	row := q.db.QueryRow(ctx, getGlobalSpend, arg.Starttime, arg.Starttime_2)
	var i GetGlobalSpendRow
	err := row.Scan(&i.TotalSpend, &i.TotalTokens, &i.RequestCount)
	return i, err
}

const getGlobalSpendByProvider = `-- name: GetGlobalSpendByProvider :many
SELECT SPLIT_PART(model, '/', 1) AS provider, SUM(spend) AS total_spend,
       COUNT(*) AS request_count
FROM "SpendLogs"
WHERE starttime >= $1 AND starttime < $2
GROUP BY provider
ORDER BY total_spend DESC
`

type GetGlobalSpendByProviderParams struct {
	Starttime   pgtype.Timestamptz `json:"starttime"`
	Starttime_2 pgtype.Timestamptz `json:"starttime_2"`
}

type GetGlobalSpendByProviderRow struct {
	Provider     string `json:"provider"`
	TotalSpend   int64  `json:"total_spend"`
	RequestCount int64  `json:"request_count"`
}

func (q *Queries) GetGlobalSpendByProvider(ctx context.Context, arg GetGlobalSpendByProviderParams) ([]GetGlobalSpendByProviderRow, error) {
	rows, err := q.db.Query(ctx, getGlobalSpendByProvider, arg.Starttime, arg.Starttime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGlobalSpendByProviderRow
	for rows.Next() {
		var i GetGlobalSpendByProviderRow
		if err := rows.Scan(&i.Provider, &i.TotalSpend, &i.RequestCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIPWhitelist = `-- name: GetIPWhitelist :one
SELECT id, ip_address, description, created_by, created_at FROM "IPWhitelistTable" WHERE id = $1
`

func (q *Queries) GetIPWhitelist(ctx context.Context, id string) (IPWhitelistTable, error) {
	row := q.db.QueryRow(ctx, getIPWhitelist, id)
	var i IPWhitelistTable
	err := row.Scan(
		&i.ID,
		&i.IpAddress,
		&i.Description,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getSpendArchive = `-- name: GetSpendArchive :one
SELECT id, date_from, date_to, storage_type, storage_location, entry_count, exported_at FROM "SpendArchiveTable" WHERE id = $1
`

func (q *Queries) GetSpendArchive(ctx context.Context, id string) (SpendArchiveTable, error) {
	row := q.db.QueryRow(ctx, getSpendArchive, id)
	var i SpendArchiveTable
	err := row.Scan(
		&i.ID,
		&i.DateFrom,
		&i.DateTo,
		&i.StorageType,
		&i.StorageLocation,
		&i.EntryCount,
		&i.ExportedAt,
	)
	return i, err
}

const getSpendArchiveByDateRange = `-- name: GetSpendArchiveByDateRange :many
SELECT id, date_from, date_to, storage_type, storage_location, entry_count, exported_at FROM "SpendArchiveTable"
WHERE date_from <= $2 AND date_to >= $1
ORDER BY date_from
`

type GetSpendArchiveByDateRangeParams struct {
	DateTo   pgtype.Date `json:"date_to"`
	DateFrom pgtype.Date `json:"date_from"`
}

func (q *Queries) GetSpendArchiveByDateRange(ctx context.Context, arg GetSpendArchiveByDateRangeParams) ([]SpendArchiveTable, error) {
	rows, err := q.db.Query(ctx, getSpendArchiveByDateRange, arg.DateTo, arg.DateFrom)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SpendArchiveTable
	for rows.Next() {
		var i SpendArchiveTable
		if err := rows.Scan(
			&i.ID,
			&i.DateFrom,
			&i.DateTo,
			&i.StorageType,
			&i.StorageLocation,
			&i.EntryCount,
			&i.ExportedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpendLogsByFilter = `-- name: GetSpendLogsByFilter :many
SELECT request_id, starttime, api_key, model, spend, total_tokens, team_id, "user"
FROM "SpendLogs"
WHERE starttime >= $1 AND starttime < $2
  AND ($3::text IS NULL OR api_key = $3)
  AND ($4::text IS NULL OR team_id = $4)
  AND ($5::text IS NULL OR model = $5)
ORDER BY starttime DESC
LIMIT $6 OFFSET $7
`

type GetSpendLogsByFilterParams struct {
	Starttime   pgtype.Timestamptz `json:"starttime"`
	Starttime_2 pgtype.Timestamptz `json:"starttime_2"`
	Column3     string             `json:"column_3"`
	Column4     string             `json:"column_4"`
	Column5     string             `json:"column_5"`
	Limit       int32              `json:"limit"`
	Offset      int32              `json:"offset"`
}

type GetSpendLogsByFilterRow struct {
	RequestID   string             `json:"request_id"`
	Starttime   pgtype.Timestamptz `json:"starttime"`
	ApiKey      string             `json:"api_key"`
	Model       string             `json:"model"`
	Spend       float64            `json:"spend"`
	TotalTokens int32              `json:"total_tokens"`
	TeamID      *string            `json:"team_id"`
	User        string             `json:"user"`
}

func (q *Queries) GetSpendLogsByFilter(ctx context.Context, arg GetSpendLogsByFilterParams) ([]GetSpendLogsByFilterRow, error) {
	rows, err := q.db.Query(ctx, getSpendLogsByFilter,
		arg.Starttime,
		arg.Starttime_2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSpendLogsByFilterRow
	for rows.Next() {
		var i GetSpendLogsByFilterRow
		if err := rows.Scan(
			&i.RequestID,
			&i.Starttime,
			&i.ApiKey,
			&i.Model,
			&i.Spend,
			&i.TotalTokens,
			&i.TeamID,
			&i.User,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpendLogsForArchival = `-- name: GetSpendLogsForArchival :many
SELECT request_id, call_type, api_key, spend, total_tokens, prompt_tokens, completion_tokens, starttime, endtime, completionstartime, model, model_id, model_group, api_base, "user", metadata, cache_hit, cache_key, request_tags, team_id, end_user, requester_ip_address, organization_id, provider
FROM "SpendLogs"
WHERE starttime >= $1 AND starttime < $2
ORDER BY starttime
LIMIT $3
`

type GetSpendLogsForArchivalParams struct {
	Starttime   pgtype.Timestamptz `json:"starttime"`
	Starttime_2 pgtype.Timestamptz `json:"starttime_2"`
	Limit       int32              `json:"limit"`
}

func (q *Queries) GetSpendLogsForArchival(ctx context.Context, arg GetSpendLogsForArchivalParams) ([]SpendLog, error) {
	rows, err := q.db.Query(ctx, getSpendLogsForArchival, arg.Starttime, arg.Starttime_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SpendLog
	for rows.Next() {
		var i SpendLog
		if err := rows.Scan(
			&i.RequestID,
			&i.CallType,
			&i.ApiKey,
			&i.Spend,
			&i.TotalTokens,
			&i.PromptTokens,
			&i.CompletionTokens,
			&i.Starttime,
			&i.Endtime,
			&i.Completionstartime,
			&i.Model,
			&i.ModelID,
			&i.ModelGroup,
			&i.ApiBase,
			&i.User,
			&i.Metadata,
			&i.CacheHit,
			&i.CacheKey,
			&i.RequestTags,
			&i.TeamID,
			&i.EndUser,
			&i.RequesterIpAddress,
			&i.OrganizationID,
			&i.Provider,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamDailyActivity = `-- name: GetTeamDailyActivity :many
SELECT DATE(starttime) AS day, model, SUM(spend) AS total_spend,
       SUM(total_tokens) AS total_tokens, COUNT(*) AS request_count
FROM "SpendLogs"
WHERE team_id = $1 AND starttime >= $2 AND starttime < $3
GROUP BY DATE(starttime), model
ORDER BY day DESC, total_spend DESC
`

type GetTeamDailyActivityParams struct {
	TeamID      *string            `json:"team_id"`
	Starttime   pgtype.Timestamptz `json:"starttime"`
	Starttime_2 pgtype.Timestamptz `json:"starttime_2"`
}

type GetTeamDailyActivityRow struct {
	Day          pgtype.Date `json:"day"`
	Model        string      `json:"model"`
	TotalSpend   int64       `json:"total_spend"`
	TotalTokens  int64       `json:"total_tokens"`
	RequestCount int64       `json:"request_count"`
}

func (q *Queries) GetTeamDailyActivity(ctx context.Context, arg GetTeamDailyActivityParams) ([]GetTeamDailyActivityRow, error) {
	rows, err := q.db.Query(ctx, getTeamDailyActivity, arg.TeamID, arg.Starttime, arg.Starttime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamDailyActivityRow
	for rows.Next() {
		var i GetTeamDailyActivityRow
		if err := rows.Scan(
			&i.Day,
			&i.Model,
			&i.TotalSpend,
			&i.TotalTokens,
			&i.RequestCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserDailyActivity = `-- name: GetUserDailyActivity :many
SELECT DATE(starttime) AS day, model, SUM(spend) AS total_spend,
       SUM(total_tokens) AS total_tokens, COUNT(*) AS request_count
FROM "SpendLogs"
WHERE "user" = $1 AND starttime >= $2 AND starttime < $3
GROUP BY DATE(starttime), model
ORDER BY day DESC, total_spend DESC
`

type GetUserDailyActivityParams struct {
	User        string             `json:"user"`
	Starttime   pgtype.Timestamptz `json:"starttime"`
	Starttime_2 pgtype.Timestamptz `json:"starttime_2"`
}

type GetUserDailyActivityRow struct {
	Day          pgtype.Date `json:"day"`
	Model        string      `json:"model"`
	TotalSpend   int64       `json:"total_spend"`
	TotalTokens  int64       `json:"total_tokens"`
	RequestCount int64       `json:"request_count"`
}

func (q *Queries) GetUserDailyActivity(ctx context.Context, arg GetUserDailyActivityParams) ([]GetUserDailyActivityRow, error) {
	rows, err := q.db.Query(ctx, getUserDailyActivity, arg.User, arg.Starttime, arg.Starttime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserDailyActivityRow
	for rows.Next() {
		var i GetUserDailyActivityRow
		if err := rows.Scan(
			&i.Day,
			&i.Model,
			&i.TotalSpend,
			&i.TotalTokens,
			&i.RequestCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIPWhitelist = `-- name: ListIPWhitelist :many
SELECT id, ip_address, description, created_by, created_at FROM "IPWhitelistTable" ORDER BY created_at DESC
`

func (q *Queries) ListIPWhitelist(ctx context.Context) ([]IPWhitelistTable, error) {
	rows, err := q.db.Query(ctx, listIPWhitelist)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []IPWhitelistTable
	for rows.Next() {
		var i IPWhitelistTable
		if err := rows.Scan(
			&i.ID,
			&i.IpAddress,
			&i.Description,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSpendArchives = `-- name: ListSpendArchives :many
SELECT id, date_from, date_to, storage_type, storage_location, entry_count, exported_at FROM "SpendArchiveTable" ORDER BY date_from DESC
`

func (q *Queries) ListSpendArchives(ctx context.Context) ([]SpendArchiveTable, error) {
	rows, err := q.db.Query(ctx, listSpendArchives)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SpendArchiveTable
	for rows.Next() {
		var i SpendArchiveTable
		if err := rows.Scan(
			&i.ID,
			&i.DateFrom,
			&i.DateTo,
			&i.StorageType,
			&i.StorageLocation,
			&i.EntryCount,
			&i.ExportedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
