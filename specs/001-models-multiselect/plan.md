# Implementation Plan: Models Multi-Select for Create API Key

**Branch**: `001-models-multiselect` | **Date**: 2026-02-24 | **Spec**: [specs/001-models-multiselect/spec.md](./spec.md)  
**Input**: Feature specification from `/specs/001-models-multiselect/spec.md`

---

## Summary

Replace the free-text comma-separated "Models" input field in the **Create API Key** form (and the **Edit Key Settings** form) with a structured multi-select that presents all currently configured proxy models as selectable checkboxes, plus a prominent "All Models" option. No DB schema changes, no new API endpoints — the change is contained to the UI layer (`internal/ui/`).

---

## Technical Context

**Language/Version**: Go 1.26 (module `github.com/praxisllmlab/tianjiLLM`)  
**Primary Dependencies**: `a-h/templ` (server-side HTML components), HTMX (partial page updates), templUI component library (existing — `internal/ui/components/`)  
**Storage**: PostgreSQL via sqlc — `VerificationToken.models text[]` column already exists; **no schema change**  
**Testing**: `go test` + `testify`; contract tests in `test/contract/` (`ui_test.go`, `key_management_test.go`)  
**Target Platform**: Linux server (web UI served at `/ui/`)  
**Performance Goals**: Page render ≤ 200ms p95 (no change from current baseline; model list ≤ 100 items)  
**Constraints**: No external JS dependencies; inline `<script>` for toggle logic only; templ files must be regenerated via `templ generate` after edit  
**Scale/Scope**: Single-page UI change affecting 2 templ files and 1 handler file

---

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Notes |
|-----------|--------|-------|
| I. Python-First Reference | ✅ PASS | Models selector is a UI feature unique to the Go UI — no Python TianjiLLM UI equivalent. The underlying `allowed_models` semantics (empty = unrestricted) match Python behavior. |
| II. Feature Parity | ✅ PASS | The API key's `models` field semantics are unchanged. External API contracts are unaffected. |
| III. Research Before Build | ✅ PASS | Research completed; see `research.md`. All decisions backed by codebase review. |
| IV. Test-Driven Migration | ✅ PASS | Existing `test/contract/ui_test.go` and `test/contract/key_management_test.go` provide test coverage points. New unit tests for `loadKeysPageData` (model list loading) are required. |
| V. Go Best Practices | ✅ PASS | No new abstractions beyond what's needed. No nesting > 3 levels. Error handling via standard `error` returns. |
| VI. No Stale Knowledge | ✅ PASS | All design decisions derived from codebase inspection, not agent memory. |
| VII. sqlc-First DB Access | ✅ PASS | Uses existing `ListProxyModels` sqlc query. **No hand-written SQL.** No new queries needed. |

**Post-Phase 1 Re-check**: All principles still hold. Design uses existing sqlc queries and adds no DB layer code.

---

## Project Structure

### Documentation (this feature)

```text
specs/001-models-multiselect/
├── plan.md              ← This file
├── spec.md              ← Feature specification
├── research.md          ← Phase 0 output (complete)
├── data-model.md        ← Phase 1 output (complete)
├── quickstart.md        ← Phase 1 output (complete)
└── tasks.md             ← Phase 2 output (created by /speckit.tasks — NOT this command)
```

### Source Code Changes

```text
internal/ui/
├── handler_keys.go          ← MODIFY: loadKeysPageData, handleKeyCreate, handleKeyUpdate
├── pages/
│   ├── keys.templ           ← MODIFY: KeysPageData struct, createKeyForm template
│   ├── keys_templ.go        ← REGENERATED by `templ generate`
│   ├── key_detail.templ     ← MODIFY: KeyDetailData struct, edit settings form
│   └── key_detail_templ.go  ← REGENERATED by `templ generate`
└── (no new files required)

test/
└── contract/
    ├── ui_test.go             ← EXTEND: add multi-select rendering assertions
    └── key_management_test.go ← EXTEND: add create-key-with-models test cases
```

**Structure Decision**: Single-project Go server. UI-only change; no new packages or files needed. The existing `internal/ui/` package handles all modifications in-place.

---

## Phase 0: Research — Complete

All unknowns resolved. See [`research.md`](./research.md) for full decision log.

**Key decisions:**
1. Custom inline checkbox-inside-popover/details pattern (no new shared component)
2. Model name source: `ListProxyModels` (DB) + `Config.ModelList` (YAML), deduplicated
3. Form encoding: repeated `name="models"` checkboxes + `all_models` sentinel hidden field
4. Scope: both Create and Edit forms updated
5. Backend: `r.Form["models"]` replaces `parseCSV(r.FormValue("models"))`

---

## Phase 1: Design — Complete

Artifacts: [`data-model.md`](./data-model.md), [`quickstart.md`](./quickstart.md)

---

## Detailed Implementation Plan

### Step 1 — `pages.KeysPageData`: Add `AvailableModels`

**File**: `internal/ui/pages/keys.templ`

```go
type KeysPageData struct {
    // ... all existing fields unchanged ...

    // AvailableModels is the list of model names configured in the proxy.
    // Used to populate the Models multi-select in the Create Key form.
    // Empty slice means no models are configured; "All Models" is always shown.
    AvailableModels []string
}
```

---

### Step 2 — `handler_keys.go`: Populate `AvailableModels` in `loadKeysPageData`

**File**: `internal/ui/handler_keys.go`

Add after loading teams/users (before building filter params):

```go
// Load available model names for the models selector.
data.AvailableModels = h.loadAvailableModelNames(r.Context())
```

New helper (private, in `handler_keys.go`):

```go
// loadAvailableModelNames returns deduplicated model names from DB + YAML config.
// Follows the same merge logic as loadModelsPageData in handler_models.go.
func (h *UIHandler) loadAvailableModelNames(ctx context.Context) []string {
    seen := map[string]struct{}{}
    var names []string

    // DB models (authoritative source when DB is available).
    if h.DB != nil {
        rows, err := h.DB.ListProxyModels(ctx)
        if err == nil {
            for _, m := range rows {
                if _, ok := seen[m.ModelName]; !ok {
                    seen[m.ModelName] = struct{}{}
                    names = append(names, m.ModelName)
                }
            }
        }
    }

    // YAML config models (fill in any not already in DB list).
    if h.Config != nil {
        for _, m := range h.Config.ModelList {
            if _, ok := seen[m.ModelName]; !ok {
                seen[m.ModelName] = struct{}{}
                names = append(names, m.ModelName)
            }
        }
    }

    return names
}
```

---

### Step 3 — `handler_keys.go`: Fix `handleKeyCreate` Form Parsing

**File**: `internal/ui/handler_keys.go`

Replace:
```go
modelsStr := r.FormValue("models")
// ...
models := parseCSV(modelsStr)
```

With:
```go
allModels := r.FormValue("all_models") // "1" = All Models selected
var models []string
if allModels != "1" {
    models = r.Form["models"] // repeated form values from checkboxes
    // nil/empty slice → no restriction (treated as All Models per spec FR-008)
}
```

---

### Step 4 — `handler_keys.go`: Fix `handleKeyUpdate` Form Parsing

**File**: `internal/ui/handler_keys.go`

In `handleKeyUpdate`, replace:
```go
modelsStr := r.FormValue("models")
// ...
if modelsStr != "" {
    params.Models = parseCSV(modelsStr)
}
```

With:
```go
allModels := r.FormValue("all_models")
if allModels == "1" {
    params.Models = []string{} // explicitly unrestricted
} else {
    selectedModels := r.Form["models"]
    if selectedModels != nil {
        params.Models = selectedModels
    }
}
```

Also: `handleKeyUpdate` needs `AvailableModels` in the error-path re-render.
Load it when building `data` for error responses:
```go
data.AvailableModels = h.loadAvailableModelNames(r.Context())
```

---

### Step 5 — `keys.templ`: Replace Free-Text Models Input with Multi-Select

**File**: `internal/ui/pages/keys.templ`

In `createKeyForm`, replace the models `<div class="space-y-2">` block:

**Remove**:
```templ
<div class="space-y-2">
    <label for="models" class="text-sm font-medium">Models (comma-separated)</label>
    @input.Input(input.Props{
        ID: "models", Name: "models",
        Placeholder: "gpt-4, claude-sonnet-4-5-20250929",
    })
</div>
```

**Replace with**:
```templ
<div class="space-y-2">
    <label class="text-sm font-medium">Models</label>
    @modelsMultiSelect("create", data.AvailableModels, []string{})
</div>
```

Add new helper template:

```templ
// modelsMultiSelect renders a checkbox-based multi-select for model selection.
// formPrefix is used to namespace IDs ("create" or "edit").
// available is the list of all model names from the proxy.
// selected is the list of currently selected model names (for edit form pre-fill).
templ modelsMultiSelect(formPrefix string, available []string, selected []string) {
    // Build a lookup set for pre-selected models.
    {{ selectedSet := make(map[string]bool, len(selected)) }}
    for _, s := range selected {
        {{ selectedSet[s] = true }}
    }
    {{ allModelsChecked := len(selected) == 0 }}

    <input type="hidden" name="all_models" id={ formPrefix + "-all-models-hidden" }
        if allModelsChecked {
            value="1"
        } else {
            value="0"
        }
    />

    <details class="rounded-md border border-input bg-background">
        <summary class="flex cursor-pointer select-none items-center justify-between px-3 py-2 text-sm">
            <span id={ formPrefix + "-models-summary" }>
                if allModelsChecked || len(available) == 0 {
                    All Models
                } else {
                    { fmt.Sprintf("%d model(s) selected", len(selected)) }
                }
            </span>
            @icon.ChevronDown(icon.Props{Size: 16, Class: "text-muted-foreground"})
        </summary>
        <div class="border-t border-input px-3 py-2 space-y-1 max-h-48 overflow-y-auto">
            <!-- All Models option -->
            <label class="flex items-center gap-2 text-sm cursor-pointer py-0.5">
                <input
                    type="checkbox"
                    id={ formPrefix + "-model-all" }
                    class="h-4 w-4 rounded border-input"
                    if allModelsChecked || len(available) == 0 {
                        checked
                    }
                    onchange={ toggleAllModels(formPrefix) }
                />
                <span class="font-medium">All Models</span>
            </label>
            if len(available) > 0 {
                <div class="border-t border-input my-1"></div>
                for _, m := range available {
                    <label class="flex items-center gap-2 text-sm cursor-pointer py-0.5">
                        <input
                            type="checkbox"
                            name="models"
                            value={ m }
                            class={ formPrefix + "-model-checkbox h-4 w-4 rounded border-input" }
                            if selectedSet[m] {
                                checked
                            }
                            if allModelsChecked {
                                disabled
                            }
                            onchange={ updateModelsSummary(formPrefix) }
                        />
                        <span class="font-mono text-xs">{ m }</span>
                    </label>
                }
            }
        </div>
    </details>
}

script toggleAllModels(formPrefix string) {
    var allCheckbox = document.getElementById(formPrefix + '-model-all');
    var hidden = document.getElementById(formPrefix + '-all-models-hidden');
    var individualBoxes = document.querySelectorAll('.' + formPrefix + '-model-checkbox');
    if (allCheckbox.checked) {
        hidden.value = '1';
        individualBoxes.forEach(function(cb) { cb.checked = false; cb.disabled = true; });
        document.getElementById(formPrefix + '-models-summary').textContent = 'All Models';
    } else {
        hidden.value = '0';
        individualBoxes.forEach(function(cb) { cb.disabled = false; });
        updateModelsSummary(formPrefix);
    }
}

script updateModelsSummary(formPrefix string) {
    var allCheckbox = document.getElementById(formPrefix + '-model-all');
    if (allCheckbox.checked) { return; }
    var hidden = document.getElementById(formPrefix + '-all-models-hidden');
    var checked = document.querySelectorAll('.' + formPrefix + '-model-checkbox + span, .' + formPrefix + '-model-checkbox:checked');
    var count = document.querySelectorAll('.' + formPrefix + '-model-checkbox:checked').length;
    hidden.value = '0';
    var summary = document.getElementById(formPrefix + '-models-summary');
    if (count === 0) {
        hidden.value = '1';
        allCheckbox.checked = true;
        summary.textContent = 'All Models';
    } else {
        summary.textContent = count + ' model(s) selected';
    }
}
```

> **Note**: The `templ` compiler handles `script` blocks as typed JS functions callable from template attributes. This is the existing project pattern (see `copyToClipboard` in `keys.templ`).

---

### Step 6 — `key_detail.templ`: Add `AvailableModels` and Replace Edit Form Input

**File**: `internal/ui/pages/key_detail.templ`

1. Add `AvailableModels []string` to `KeyDetailData` struct.

2. In the edit settings form (within `EditSettingsForm` or the models input section), replace the `models` text input with `@modelsMultiSelect(...)`.

   Since `modelsMultiSelect` is defined in `keys.templ` (same package `pages`), it is directly callable from `key_detail.templ`.

   ```templ
   // In the edit form models section:
   <div class="space-y-2">
       <label class="text-sm font-medium">Models</label>
       @modelsMultiSelect("edit", data.AvailableModels, data.Models)
   </div>
   ```

---

### Step 7 — `handler_keys.go`: Populate `AvailableModels` for Key Detail Handlers

**File**: `internal/ui/handler_keys.go`

In `handleKeyDetail`, `handleKeyEdit`, `handleKeyUpdate` (success and error paths):

```go
data.AvailableModels = h.loadAvailableModelNames(r.Context())
```

---

### Step 8 — `templ generate`

After all `.templ` file edits:

```bash
templ generate
go build ./...
```

---

### Step 9 — Tests

**New unit test** in `internal/ui/` (or `handler_keys_test.go`):

```go
func TestLoadAvailableModelNames(t *testing.T) {
    // Test: DB models + config models are merged, deduplicated
    // Test: DB nil → falls back to config only
    // Test: empty config + empty DB → returns []string{}
}
```

**Extend contract tests** (`test/contract/key_management_test.go`):

```go
// TestCreateKeyWithSpecificModels:
//   POST /ui/keys/create with all_models=0&models=gpt-4&models=claude-3
//   Verify key row shows "gpt-4, claude-3"
//   Verify DB VerificationToken.Models == ["gpt-4", "claude-3"]

// TestCreateKeyWithAllModels:
//   POST /ui/keys/create with all_models=1
//   Verify key row shows "All Models" badge
//   Verify DB VerificationToken.Models == []

// TestCreateKeyNoModelCheckbox:
//   POST /ui/keys/create with all_models=0 and no models= values
//   Verify treated as All Models (empty slice)
```

---

## Complexity Tracking

No constitution violations. No complexity justification required.

---

## Phase Artifacts Summary

| Artifact | Path | Status |
|----------|------|--------|
| `research.md` | `specs/001-models-multiselect/research.md` | ✅ Complete |
| `data-model.md` | `specs/001-models-multiselect/data-model.md` | ✅ Complete |
| `quickstart.md` | `specs/001-models-multiselect/quickstart.md` | ✅ Complete |
| `plan.md` | `specs/001-models-multiselect/plan.md` | ✅ This file |
| `tasks.md` | `specs/001-models-multiselect/tasks.md` | ⏳ Next: `/speckit.tasks` |

---

## Implementation Checklist (pre-tasks)

- [ ] `pages.KeysPageData` struct: add `AvailableModels []string`
- [ ] `pages.KeyDetailData` struct: add `AvailableModels []string`
- [ ] `handler_keys.go`: add `loadAvailableModelNames` helper
- [ ] `handler_keys.go`: call `loadAvailableModelNames` in `loadKeysPageData`
- [ ] `handler_keys.go`: call `loadAvailableModelNames` in key detail handlers
- [ ] `handler_keys.go`: fix `handleKeyCreate` form parsing (all_models + r.Form["models"])
- [ ] `handler_keys.go`: fix `handleKeyUpdate` form parsing (all_models + r.Form["models"])
- [ ] `keys.templ`: add `modelsMultiSelect` template + JS scripts
- [ ] `keys.templ`: replace free-text models input in `createKeyForm`
- [ ] `key_detail.templ`: replace free-text models input in edit settings form
- [ ] Run `templ generate`
- [ ] Run `go build ./...`
- [ ] Write/extend unit tests for `loadAvailableModelNames`
- [ ] Write/extend contract tests for create-key with models
- [ ] Manual verification against quickstart checklist
