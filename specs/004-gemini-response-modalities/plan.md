# Implementation Plan: Gemini Response Modalities (Image Output)

**Branch**: `feat/gemini-response-modalities` (spec: `004-gemini-response-modalities`)
**Date**: 2026-02-26
**Spec**: `specs/004-gemini-response-modalities/spec.md`

## Summary

Add support for Gemini image output (`modalities: ["text", "image"]`) through the
TianjiLLM proxy. When a client sends `modalities: ["text", "image"]`, the proxy
translates to `generationConfig.responseModalities: ["TEXT", "IMAGE"]` upstream, then
maps returned `inlineData` parts back to OpenAI-compatible `image_url` content parts.
Text-only flows are unchanged.

Changes are confined to 4 files:
- `internal/model/request.go` â€” add `Modalities` field
- `internal/provider/gemini/gemini.go` â€” upstream request mapping + response transformation
- `internal/provider/gemini/stream.go` â€” streaming `inlineData` handling
- `internal/provider/gemini/gemini_test.go` â€” new unit tests

No new libraries, no DB changes, no migrations.

---

## Technical Context

**Language/Version**: Go 1.24.4
**Primary Dependencies**: stdlib only (`encoding/json`, `strings`, `fmt`) â€” no new imports
**Storage**: N/A â€” purely in-memory transformation
**Testing**: `go test` + `testify` (existing)
**Target Platform**: Linux server (existing deployment)
**Project Type**: Single Go service
**Performance Goals**: SC-005 â€” zero latency overhead for text-only requests
**Constraints**: No breaking change to existing response format (FR-007)
**Scale/Scope**: 4 files modified, ~100 lines net addition

---

## Constitution Check

### I. Python-First Reference
- Python TianjiLLM not available locally. Gemini API behavior confirmed from spec
  assertions and existing Go code patterns.
- **Status**: âš ï¸ Deviation documented â€” Python codebase unavailable in this environment.
  Implementation follows Gemini API documentation (from spec) and existing Go patterns.

### II. Feature Parity
- `modalities` field maps to Gemini `responseModalities` (uppercase values) as per
  spec assumption and Gemini API docs.
- Response format (`image_url` with data URL) matches OpenAI conventions for inline images.
- **Status**: âœ… Compliant

### III. Research Before Build
- Research documented in `research.md`.
- No new libraries evaluated â€” change uses only existing stdlib.
- **Status**: âœ… Compliant

### IV. Test-Driven Migration
- Unit tests will cover all 3 mapping paths (SC-004):
  - text-only â†’ plain string (regression test)
  - image-only â†’ array with `image_url`
  - mixed text+image â†’ array preserving order
- **Status**: âœ… Compliant

### V. Go Best Practices
- New `geminiInlineData` struct uses JSON tags with `omitempty`.
- No new nesting levels added.
- Helper functions stay single-purpose.
- **Status**: âœ… Compliant

### VI. No Stale Knowledge
- `modalities` â†’ `responseModalities` mapping confirmed from spec (issue #17).
- No external library API calls to verify.
- **Status**: âœ… Compliant

### VII. sqlc-First Database Access
- N/A â€” no database queries.
- **Status**: âœ… N/A

---

## Project Structure

### Documentation (this feature)

```text
specs/004-gemini-response-modalities/
â”œâ”€â”€ plan.md              # This file
â”œâ”€â”€ research.md          # Decisions documented
â”œâ”€â”€ data-model.md        # Struct changes + mapping tables
â”œâ”€â”€ quickstart.md        # How to test manually
â”œâ”€â”€ contracts/           # JSON fixtures for all scenarios
â”‚   â”œâ”€â”€ request-image-output.json
â”‚   â”œâ”€â”€ request-image-to-image.json
â”‚   â”œâ”€â”€ gemini-upstream-request.json
â”‚   â”œâ”€â”€ gemini-upstream-response.json
â”‚   â”œâ”€â”€ response-mixed-content.json
â”‚   â””â”€â”€ response-text-only-unchanged.json
â””â”€â”€ tasks.md             # Generated by /speckit.tasks (not yet)
```

### Source Code

```text
internal/
â”œâ”€â”€ model/
â”‚   â””â”€â”€ request.go          # Add Modalities field + knownFields entry
â””â”€â”€ provider/
    â””â”€â”€ gemini/
        â”œâ”€â”€ gemini.go        # Core changes (4 locations)
        â”œâ”€â”€ gemini_test.go   # New tests (3 new test functions)
        â””â”€â”€ stream.go        # inlineData handling in streaming
```

---

## Implementation Details

### Change 1: `internal/model/request.go`

**Add `Modalities` field to `ChatCompletionRequest`**:
```go
Modalities []string `json:"modalities,omitempty"` // NEW: e.g. ["text", "image"]
```

**Add to `knownFields` map**:
```go
"modalities": true,
```

---

### Change 2: `internal/provider/gemini/gemini.go` â€” 4 sub-changes

#### 2a. Add `geminiInlineData` struct + update `geminiPart`

```go
type geminiInlineData struct {
    MimeType string `json:"mimeType"`
    Data     string `json:"data"`
}

// geminiPart: add InlineData field
type geminiPart struct {
    Text         string            `json:"text,omitempty"`
    FunctionCall *geminiFuncCall   `json:"functionCall,omitempty"`
    InlineData   *geminiInlineData `json:"inlineData,omitempty"` // NEW
}
```

#### 2b. `transformRequestBody` â€” inject `responseModalities`

After the existing `generationConfig` block, add:
```go
if len(req.Modalities) > 0 {
    modalities := make([]string, 0, len(req.Modalities))
    for _, m := range req.Modalities {
        modalities = append(modalities, strings.ToUpper(m))
    }
    genConfig["responseModalities"] = modalities
}
```

Handles: `["text", "image"]` â†’ `["TEXT", "IMAGE"]`. Empty `req.Modalities` â†’ no field
set (preserves FR-003 / SC-005).

#### 2c. `transformToOpenAI` â€” handle mixed content

Replace the `strings.Builder` accumulation in the parts loop:

```go
// In the candidate parts loop, detect whether any inlineData exists
var textParts []string
var contentParts []model.ContentPart
hasImage := false

for _, part := range candidate.Content.Parts {
    if part.InlineData != nil {
        hasImage = true
        contentParts = append(contentParts, model.ContentPart{
            Type: "image_url",
            ImageURL: &model.ImageURL{
                URL: "data:" + part.InlineData.MimeType + ";base64," + part.InlineData.Data,
            },
        })
    } else if part.Text != "" {
        textParts = append(textParts, part.Text)
        contentParts = append(contentParts, model.ContentPart{
            Type: "text",
            Text: part.Text,
        })
    }
    // ... existing FunctionCall handling unchanged
}

// Set message.Content
if hasImage {
    msg.Content = contentParts  // []ContentPart â€” typed array
} else {
    msg.Content = strings.Join(textParts, "")  // plain string â€” no regression
}
```

#### 2d. Fix `transformContentPart` for image input data URLs

Current code passes the full data URL as `inlineData.data` which is wrong. Fix:

```go
case "image_url":
    if imageURL, ok := part["image_url"].(map[string]any); ok {
        url, _ := imageURL["url"].(string)
        mimeType := "image/jpeg"
        data := url
        if strings.HasPrefix(url, "data:") {
            // Parse: data:<mimeType>;base64,<data>
            rest := strings.TrimPrefix(url, "data:")
            if idx := strings.Index(rest, ";base64,"); idx >= 0 {
                mimeType = rest[:idx]
                data = rest[idx+len(";base64,"):]
            }
        }
        return map[string]any{
            "inlineData": map[string]any{
                "mimeType": mimeType,
                "data":     data,
            },
        }
    }
```

---

### Change 3: `internal/provider/gemini/stream.go`

In `ParseStreamChunk`, add `inlineData` handling alongside existing text/toolCall logic:

```go
for _, part := range candidate.Content.Parts {
    if part.InlineData != nil {
        // Encode as JSON string for streaming delta content
        imgPart := model.ContentPart{
            Type: "image_url",
            ImageURL: &model.ImageURL{
                URL: "data:" + part.InlineData.MimeType + ";base64," + part.InlineData.Data,
            },
        }
        b, _ := json.Marshal(imgPart)
        imgStr := string(b)
        delta.Content = &imgStr  // JSON-encoded content part for streaming
    }
    if part.Text != "" {
        delta.Content = &part.Text
    }
    // ... existing FunctionCall handling
}
```

---

### Change 4: `internal/provider/gemini/gemini_test.go`

**New test functions to add**:

1. `TestTransformResponse_ImageOutput` â€” image-only response â†’ `[]ContentPart`
2. `TestTransformResponse_MixedContent` â€” text + image parts â†’ array, order preserved
3. `TestTransformRequest_WithModalities` â€” verifies `responseModalities` in upstream request
4. `TestTransformResponse_TextOnlyBackwardCompat` â€” no regression for text-only

Use fixtures from `contracts/` as expected values (inline them as Go string literals).

---

## Complexity Tracking

No constitution violations. No complexity justification needed.

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| `message.Content` type change breaks JSON marshaling | Low | High | Existing `Content any` field handles both string and []ContentPart |
| Gemini returns inlineData chunks in streaming | Medium | Low | Stream handler processes them; existing text streaming unaffected |
| Data URL extraction regex edge cases | Low | Low | Simple prefix/index parsing; falls back to raw URL |
| Existing text tests break | Very Low | High | Branch on `hasImage` bool; text path unchanged |

---

## Non-Goals

- Vertex AI image generation (same code path, no special handling needed)
- Audio modalities (not in spec, not implemented)
- Image output caching
- Client-side image validation (proxy passes through)

---

## Review Feedback (2026-02-26)

### ğŸ”§ Tech Review (é­¯ç­) â€” `review-tech.md`

**Must-fix:**
1. **Streaming image â€” Delta.Content æ˜¯ `*string`ï¼Œä¸èƒ½å¡ JSON ContentPartã€‚**
   - **èª¿ç ”çµè«–ï¼š** Gemini streaming image æ˜¯æ•´å¼µåœ–ä¸€å€‹ chunkï¼ˆä¸ incrementally streamï¼‰ï¼ŒåŒ function call args è¡Œç‚ºã€‚
   - **æ±ºå®šï¼š** æ“´å…… `Delta` struct æ–°å¢ `ContentParts []ContentPart` æ¬„ä½ã€‚ç•¶ streaming chunk å« `inlineData` æ™‚ï¼Œç”¨ `ContentParts` è€Œé `Content`ã€‚SSE event çš„ `delta` ç‰©ä»¶æœƒåŒ…å« `content_parts` arrayã€‚Client éœ€æª¢æŸ¥ `delta.content_parts`ï¼ˆæœ‰å€¼æ™‚ï¼‰æˆ– `delta.content`ï¼ˆç´”æ–‡å­—æ™‚ï¼‰ã€‚é€™ç¬¦åˆ OpenAI çš„ multimodal streaming æ¼”é€²æ–¹å‘ã€‚
2. **`genConfig` æ³¨å…¥ä½ç½®ï¼š** `responseModalities` å¿…é ˆåœ¨ `if len(genConfig) > 0` åˆ¤æ–·**ä¹‹å‰**åŠ å…¥ `genConfig` mapï¼Œå¦å‰‡ç©º map æ™‚ä¸æœƒè¢«å¯«å…¥ bodyã€‚

**Important fix:**
3. **`modalities: ["text"]` ä¸è©²è¨­ `responseModalities`ï¼ˆé•å FR-003ï¼‰ã€‚** æ”¹ç‚ºåªæœ‰åŒ…å« `"image"` æ™‚æ‰è¨­ `responseModalities`ï¼š
   ```go
   hasImage := false
   for _, m := range req.Modalities {
       if strings.EqualFold(m, "image") { hasImage = true; break }
   }
   if hasImage {
       modalities := make([]string, 0, len(req.Modalities))
       for _, m := range req.Modalities { modalities = append(modalities, strings.ToUpper(m)) }
       genConfig["responseModalities"] = modalities
   }
   ```

### ğŸ§ª Test Review (é­å¾µ) â€” `review-test.md`

**P0 ç¼ºå£ï¼ˆmust-addï¼‰ï¼š**
1. `TestStreamParseChunk_ImageInlineData` â€” streaming `inlineData` è™•ç†
2. `TestTransformContentPart_DataURLParsing` â€” data URL è§£æ regression test

**P1 å»ºè­°å¢åŠ ï¼š**
3. `TestTransformRequest_ModalitiesTextOnly` â€” `["text"]` ä¸è¨­ `responseModalities`
4. `TestTransformRequest_ModalitiesEmpty` â€” `[]` ä¸è¨­ `responseModalities`
5. `TestTransformResponse_UnknownMimeType` â€” æœªçŸ¥ MIME type passthrough
6. `TestTransformResponse_ImageInputRoundTrip` â€” image input + output round-trip

**æ¸¬è©¦ç¸½æ•¸ï¼š** å¾ 4 â†’ 10ï¼ˆ4 åŸæœ‰ + 2 P0 + 4 P1ï¼‰

### ğŸ¨ UI/UX Review (å¼µå¤§åƒ) â€” `review-uiux.md`

**çµè«–ï¼šâœ… æ­¤ feature ä¸éœ€è¦ UI æ”¹å‹•**ï¼ˆç´” API proxy å±¤ï¼‰

**Low-priority follow-upï¼ˆé–‹ issue è¿½è¹¤ï¼‰ï¼š**
- Logs é é¢ï¼šimage response badge/filter
- Usage é é¢ï¼šå€åˆ† text vs image generation ç”¨é‡
- Models é é¢ï¼šcapability badges æ¨™ç¤º modalities æ”¯æ´

---

## Updated Change Summary (post-review)

| Change | File | Description |
|--------|------|-------------|
| 1 | `internal/model/request.go` | Add `Modalities []string` field |
| 2 | `internal/model/response.go` | Add `ContentParts []ContentPart` to `Delta` struct |
| 2a | `internal/provider/gemini/gemini.go` | Add `geminiInlineData` struct |
| 2b | `internal/provider/gemini/gemini.go` | Inject `responseModalities` (only when `"image"` present) |
| 2c | `internal/provider/gemini/gemini.go` | Handle mixed content in `transformToOpenAI` |
| 2d | `internal/provider/gemini/gemini.go` | Fix data URL parsing in `transformContentPart` |
| 3 | `internal/provider/gemini/stream.go` | Handle `inlineData` in streaming via `Delta.ContentParts` |
| 4 | `internal/provider/gemini/gemini_test.go` | 10 unit tests (4 original + 2 P0 + 4 P1) |
