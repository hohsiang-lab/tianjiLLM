# Implementation Plan: Auto-Run DB Migrations on Startup

**Branch**: `002-auto-db-migration` | **Date**: 2026-02-25 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `specs/002-auto-db-migration/spec.md`

## Summary

On service startup, before accepting any requests, run all pending SQL schema migrations
against the configured PostgreSQL database. Migrations are embedded in the binary,
tracked via a `schema_migrations` table, and protected by a PostgreSQL session-level
advisory lock to prevent concurrent execution across multiple instances.

**Approach**: Custom lightweight runner (~80 LOC) in a new `internal/db/migrate` package,
called from `main.go` immediately after `pool.Ping()`. No new dependencies required.

---

## Technical Context

**Language/Version**: Go 1.26 (as per `go.mod`)
**Primary Dependencies**: `github.com/jackc/pgx/v5` (already in go.mod) + stdlib `embed`, `io/fs`
**Storage**: PostgreSQL — new `schema_migrations` table (created at runtime)
**Testing**: `go test` + `testify` — integration test against real PostgreSQL
**Target Platform**: Linux server (Docker/K8s), ARM64 (OrbStack)
**Performance Goals**: Fresh deploy (<30s total), incremental (<10s/migration), failure exit (<5s)
**Constraints**: No new go.mod dependencies; must not modify existing `internal/db/schema/*.sql` files
**Scale/Scope**: 10 migration files today; designed for up to ~1000 (integer version space)

---

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Notes |
|-----------|--------|-------|
| I. Python-First Reference | ✅ EXEMPT | Python TianjiLLM has no startup migration equivalent. Deviation documented in spec Assumptions. |
| II. Feature Parity | ✅ N/A | New Go-specific operational feature |
| III. Research Before Build | ✅ PASS | See research.md — golang-migrate & goose evaluated; custom runner chosen |
| IV. Test-Driven Migration | ✅ PASS | Integration test in `test/integration/` required |
| V. Go Best Practices | ✅ PASS | `context.Context` threading, error wrapping, single-responsibility package |
| VI. No Stale Knowledge | ✅ PASS | Advisory lock, embed.FS, pgx patterns verified in research.md |
| VII. sqlc-First DB Access | ✅ PASS | `schema_migrations` DDL is runner-internal; not a sqlc query. Justified: table creation is a bootstrap operation, not a business query. All other DB access remains sqlc. |

**Gate result**: PASS — proceed to implementation.

---

## Project Structure

### Documentation (this feature)

```text
specs/002-auto-db-migration/
├── plan.md              ← this file
├── research.md          ← technology decisions
├── data-model.md        ← schema_migrations table definition
└── tasks.md             ← generated by speckit-tasks
```

### Source Code Changes

```text
internal/db/
├── migrate/
│   ├── migrate.go       ← NEW: Runner + embed directive + RunMigrations()
│   └── migrate_test.go  ← NEW: unit tests (mock DB via interface)
└── schema/              ← UNCHANGED (existing .sql files)

test/integration/
└── migration_test.go    ← NEW: integration test against real PostgreSQL

cmd/tianji/
└── main.go              ← MODIFIED: call migrate.RunMigrations() after pool.Ping()
```

---

## Implementation Phases

### Phase 1: Core Migration Runner

**File**: `internal/db/migrate/migrate.go`

**Responsibilities**:
1. Embed all `*.sql` files from `../schema/`
2. Parse version numbers from filenames (`001_initial.sql` → version 1)
3. Create `schema_migrations` table if not exists
4. Acquire PostgreSQL advisory lock (session-level, blocks until acquired)
5. Query already-applied versions
6. For each pending migration (in ascending version order): run inside a transaction, record in `schema_migrations`
7. Release advisory lock (implicit on connection close / explicit)
8. Return summary (applied count)

**Public API**:
```go
// RunMigrations applies all pending migrations to the database.
// It blocks until a database-level lock is acquired, ensuring safe
// concurrent startup. Returns an error if any migration fails.
func RunMigrations(ctx context.Context, pool *pgxpool.Pool) error
```

**Advisory lock key**: `hashtext('tianjiLLM-migrations')` — deterministic, stable.

**schema_migrations DDL** (executed first, before lock):
```sql
CREATE TABLE IF NOT EXISTS schema_migrations (
    version    INTEGER      PRIMARY KEY,
    name       TEXT         NOT NULL,
    applied_at TIMESTAMPTZ  NOT NULL DEFAULT now()
);
```

**Migration execution** (per file, inside transaction):
```sql
-- 1. acquire advisory lock
SELECT pg_advisory_lock(hashtext('tianjiLLM-migrations')::bigint);
-- 2. (in tx) run migration SQL
-- 3. (in tx) record applied
INSERT INTO schema_migrations (version, name) VALUES ($1, $2);
-- 4. COMMIT tx (lock released implicitly on conn return to pool)
```

---

### Phase 2: main.go Integration

**File**: `cmd/tianji/main.go`

**Change**: After `pool.Ping()` succeeds and before `queries = db.New(pool)`, insert:

```go
log.Println("running database migrations...")
if err := migrate.RunMigrations(ctx, pool); err != nil {
    log.Fatalf("migration failed: %v", err)
}
```

No migration is attempted when `cfg.GeneralSettings.DatabaseURL == ""` (existing no-DB path unchanged).

---

### Phase 3: Tests

**Unit test** (`internal/db/migrate/migrate_test.go`):
- Test `parseVersion("001_initial.sql")` → 1
- Test `parseVersion("010_org_membership.sql")` → 10
- Test filename sorting (versions 1–10 in correct order)
- Test with already-applied versions (skip logic)

**Integration test** (`test/integration/migration_test.go`):
- Requires `E2E_DATABASE_URL` env var (reuses existing test infra)
- Test 1: fresh DB → all 10 migrations applied, `schema_migrations` has 10 rows
- Test 2: call `RunMigrations` twice → idempotent, still 10 rows
- Test 3: corrupt one migration file at runtime → returns error (using table-driven test with mock embed.FS)

---

## Data Model

See `data-model.md`.

---

## Complexity Tracking

| Item | Justification |
|------|---------------|
| sqlc-First exception for `schema_migrations` DDL | Bootstrap table cannot use sqlc (sqlc requires the table to already exist to validate queries). Runner creates it directly via `pgx` — strictly limited to this one DDL statement. |
| Custom runner instead of library | golang-migrate requires `.up.sql` suffix rename; goose requires directive comments. Modifying existing schema files risks breaking sqlc validation pipeline. |
