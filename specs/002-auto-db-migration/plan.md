# Implementation Plan: Auto-Run DB Migrations on Startup

**Branch**: `002-auto-db-migration` | **Date**: 2026-02-25 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `specs/002-auto-db-migration/spec.md`

## Summary

On service startup, before accepting any requests, run all pending SQL schema migrations
using `golang-migrate/v4` with an `embed.FS` source and the native pgx/v5 driver.
Schema files are renamed from `NNN_name.sql` → `NNN_name.up.sql` — a format both
`golang-migrate` and `sqlc` officially support (sqlc docs confirmed).

---

## Technical Context

**Language/Version**: Go 1.26 (as per `go.mod`)
**New Dependencies**:
- `github.com/golang-migrate/migrate/v4`
- `github.com/golang-migrate/migrate/v4/source/iofs`
- `github.com/golang-migrate/migrate/v4/database/pgx/v5`
**Existing Dependencies Used**: `github.com/jackc/pgx/v5` (already in go.mod; stdlib bridge included)
**Storage**: PostgreSQL — `schema_migrations` table created/managed by golang-migrate
**Testing**: `go test` + integration test against real PostgreSQL
**Target Platform**: Linux server (Docker/K8s), ARM64 (OrbStack)
**Performance Goals**: Fresh deploy <30s total; incremental <10s/migration; failure exit <5s
**Constraints**: Must not break sqlc pipeline (`make generate` must still pass)

---

## Constitution Check

| Principle | Status | Notes |
|-----------|--------|-------|
| I. Python-First Reference | ✅ EXEMPT | Python TianjiLLM has no startup migration equivalent. Documented in spec. |
| II. Feature Parity | ✅ N/A | New Go-specific operational feature |
| III. Research Before Build | ✅ PASS | golang-migrate chosen; verified sqlc + golang-migrate compatibility via official docs |
| IV. Test-Driven Migration | ✅ PASS | Integration test required |
| V. Go Best Practices | ✅ PASS | `context.Context` threading, prefer library over custom |
| VI. No Stale Knowledge | ✅ PASS | All claims verified from source code and official docs |
| VII. sqlc-First DB Access | ✅ PASS | `schema_migrations` DDL managed by golang-migrate internally |

**Gate result**: PASS

---

## Project Structure

### Documentation (this feature)

```text
specs/002-auto-db-migration/
├── plan.md              ← this file
├── research.md          ← technology decisions (updated)
├── data-model.md        ← schema_migrations table
└── tasks.md             ← generated by speckit-tasks
```

### Source Code Changes

```text
internal/db/
├── schema/                      ← RENAME only (10 files: .sql → .up.sql)
│   ├── 001_initial.up.sql
│   ├── 002_management.up.sql
│   └── ... (010 total)
└── migrate/
    ├── migrate.go               ← NEW: embed + RunMigrations()
    └── migrate_test.go          ← NEW: unit tests

cmd/tianji/
└── main.go                      ← MODIFIED: call RunMigrations after pool.Ping()

go.mod / go.sum                  ← MODIFIED: add golang-migrate deps
```

---

## Implementation Phases

### Phase 1: Rename Schema Files

Rename all 10 files in `internal/db/schema/` from `NNN_name.sql` to `NNN_name.up.sql`.

**Verification**: Run `make generate` — sqlc must still pass cleanly.
sqlc 1.30.0 natively supports golang-migrate file format and reads `.up.sql` files
from the schema directory (confirmed from official docs).

---

### Phase 2: Add golang-migrate Dependency

```bash
go get github.com/golang-migrate/migrate/v4
go get github.com/golang-migrate/migrate/v4/source/iofs
go get github.com/golang-migrate/migrate/v4/database/pgx/v5
```

---

### Phase 3: New `internal/db/migrate/migrate.go`

```go
package migrate

import (
    "context"
    "embed"
    "errors"
    "fmt"
    "log"

    "github.com/golang-migrate/migrate/v4"
    pgxv5 "github.com/golang-migrate/migrate/v4/database/pgx/v5"
    "github.com/golang-migrate/migrate/v4/source/iofs"
    "github.com/jackc/pgx/v5/pgxpool"
    "github.com/jackc/pgx/v5/stdlib"
)

//go:embed ../schema/*.up.sql
var migrationFiles embed.FS

// RunMigrations applies all pending migrations to the database.
// Blocks until a database-level advisory lock is acquired (safe for concurrent
// multi-instance startup). Returns an error if any migration fails.
func RunMigrations(ctx context.Context, pool *pgxpool.Pool) error {
    sqlDB := stdlib.OpenDBFromPool(pool)

    driver, err := pgxv5.WithInstance(sqlDB, &pgxv5.Config{})
    if err != nil {
        return fmt.Errorf("migrate: create driver: %w", err)
    }

    src, err := iofs.New(migrationFiles, "schema")
    if err != nil {
        return fmt.Errorf("migrate: create source: %w", err)
    }

    m, err := migrate.NewWithInstance("iofs", src, "pgx5", driver)
    if err != nil {
        return fmt.Errorf("migrate: init: %w", err)
    }
    m.Log = &migrateLogger{}

    if err := m.Up(); err != nil && !errors.Is(err, migrate.ErrNoChange) {
        return fmt.Errorf("migrate: up: %w", err)
    }

    return nil
}

// migrateLogger bridges golang-migrate logging to standard log.
type migrateLogger struct{}

func (l *migrateLogger) Printf(format string, v ...interface{}) {
    log.Printf("[migrate] "+format, v...)
}
func (l *migrateLogger) Verbose() bool { return false }
```

**Notes**:
- `migrate.ErrNoChange` is not an error (schema already up-to-date)
- Advisory lock: handled internally by `golang-migrate` pgx5 driver
- `schema_migrations` table: created automatically by the driver

---

### Phase 4: Wire into main.go

After `pool.Ping()` succeeds:

```go
log.Println("running database migrations...")
if err := dbmigrate.RunMigrations(ctx, pool); err != nil {
    log.Fatalf("migration failed: %v", err)
}
log.Println("migrations complete")
```

Import alias `dbmigrate` to avoid collision with the `migrate` library package name.
No change needed to the no-DB startup path (migration is only called when pool is non-nil).

---

### Phase 5: Tests

**Unit test** (`internal/db/migrate/migrate_test.go`):
- Confirm embed.FS contains expected files after rename
- Confirm iofs.New succeeds and lists correct versions (1–10)

**Integration test** (`test/integration/migration_test.go`):
- Requires `E2E_DATABASE_URL` (reuses existing test infra)
- Test 1: fresh DB → 10 migrations applied, `schema_migrations` has 10 rows
- Test 2: `RunMigrations` called again → `ErrNoChange`, idempotent
- Test 3: verify `schema_migrations` row for version 1 has expected `name` field

---

## Complexity Tracking

| Item | Justification |
|------|---------------|
| Schema file rename (.sql → .up.sql) | Required by golang-migrate iofs driver. sqlc natively supports this format — confirmed in sqlc 1.30.0 docs. Low risk: content unchanged, only filename extension changes. |
