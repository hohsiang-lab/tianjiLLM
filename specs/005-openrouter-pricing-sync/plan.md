# Implementation Plan: OpenRouter Pricing Sync

**Branch**: `005-openrouter-pricing-sync` | **Date**: 2025-06-28 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/specs/005-openrouter-pricing-sync/spec.md`

## Summary

Add OpenRouter API as a secondary pricing source to `SyncFromUpstream`. After fetching from LiteLLM (primary), fetch from OpenRouter and merge models that LiteLLM doesn't cover. This fixes HO-21 where models like `gemini-2.5-pro-preview` have $0 cost because LiteLLM's JSON lacks that key.

## Technical Context

**Language/Version**: Go (1.23+)
**Primary Dependencies**: `net/http` (stdlib), `encoding/json` (stdlib), `pgx/v5`, `sqlc`
**Storage**: PostgreSQL — existing `ModelPricing` table (no schema changes needed)
**Testing**: `go test` + `testify` + `httptest` mock servers
**Target Platform**: Linux server (Docker/K8s)
**Project Type**: single (Go monolith)
**Performance Goals**: Sync completes within 60s (combined LiteLLM + OpenRouter)
**Constraints**: OpenRouter failure must not block LiteLLM sync
**Scale/Scope**: ~2000 models from OpenRouter API

## Constitution Check

| Principle | Status | Notes |
|-----------|--------|-------|
| I. Python-First Reference | ✅ N/A | New feature, no Python equivalent |
| II. Feature Parity | ✅ N/A | Additive feature |
| III. Research Before Build | ✅ | OpenRouter API format verified via live query |
| IV. Test-Driven Migration | ✅ | Integration tests planned |
| V. Go Best Practices | ✅ | Uses stdlib HTTP, proper error handling |
| VI. No Stale Knowledge | ✅ | API format confirmed from live endpoint |
| VII. sqlc-First DB Access | ⚠️ | Existing `upsertModelPricingSQL` is raw SQL in `sync.go` (pre-existing deviation). New code follows same pattern for consistency. |

## Project Structure

### Documentation (this feature)

```text
specs/005-openrouter-pricing-sync/
├── spec.md
├── plan.md              # This file
├── research.md
├── checklists/
│   └── requirements.md
└── tasks.md             # To be generated by /speckit.tasks
```

### Source Code (modified files)

```text
internal/pricing/
├── sync.go              # MODIFY: add fetchOpenRouter(), update SyncFromUpstream()
├── sync_integration_test.go  # MODIFY: add OpenRouter merge tests
└── model_prices.json    # MODIFY: revert PR #23 manual entries

internal/ui/
└── handler_models.go    # MODIFY: read OPENROUTER_PRICING_URL env, pass to sync
```

## Design

### OpenRouter Response Parsing

OpenRouter returns:
```json
{
  "data": [
    {
      "id": "google/gemini-2.5-pro-preview",
      "pricing": {
        "prompt": "0.00000125",
        "completion": "0.00001"
      }
    }
  ]
}
```

New types in `sync.go`:
```go
type openRouterResponse struct {
    Data []openRouterModel `json:"data"`
}
type openRouterModel struct {
    ID      string            `json:"id"`
    Pricing openRouterPricing `json:"pricing"`
}
type openRouterPricing struct {
    Prompt     string `json:"prompt"`
    Completion string `json:"completion"`
}
```

### Merge Strategy

1. Fetch LiteLLM → build `litellmNames` set (all model names)
2. Fetch OpenRouter → for each model:
   - Parse `pricing.prompt` / `.completion` as `float64`
   - Skip if both are 0 or parse fails
   - Extract provider from `id` (split on first `/`)
   - Generate bare name (everything after first `/`; if no `/`, bare = id)
   - For each key (full id + bare name): skip if already in `litellmNames`
   - Append to entries list
3. Upsert all entries (LiteLLM + OpenRouter) in single transaction

### Handler Changes

`handleSyncPricing()` reads `OPENROUTER_PRICING_URL` env (default: `https://openrouter.ai/api/v1/models`). Passes both URLs to updated `SyncFromUpstream`.

### Function Signature Change

```go
// Before:
func SyncFromUpstream(ctx, pool, queries, calc, upstreamURL string) (int, error)

// After:
func SyncFromUpstream(ctx, pool, queries, calc, litellmURL string, openRouterURL string) (int, error)
```

### Graceful Degradation

OpenRouter fetch failure → `log.Printf("warning: ...")`, continue with LiteLLM-only data. No error returned for OpenRouter failure.

## Research

OpenRouter API verified live:
- Endpoint: `GET https://openrouter.ai/api/v1/models` (no auth required)
- Returns ~300+ models with pricing
- `data[].pricing.prompt` / `.completion` are string-encoded per-token costs
- Some models have `"0"` pricing (free tier) — these should be included (valid $0 cost)
- Model IDs use `provider/model` format consistently

**Decision**: Skip models where both prompt AND completion pricing are empty/null (not parseable). Keep `"0"` as valid zero-cost.
